<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>python-graphs.modules.graph.graph API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>python-graphs.modules.graph.graph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from collections import deque
import random

class Graph:
    &#34;&#34;&#34;
    Generic Class for Graphs. It shares common methods for data representations implementations such as AdjacencyList and AdjacencyMatrix.

    All basic methods to interact with Vertice and Edges needs to be override by the Child Class.

    Returns:
        Graph -- Graph Class
    &#34;&#34;&#34;

    # Vertice Key of Data Structured passed by argument
    VERTICES_KEY = &#39;vertices&#39;
    # Edge Key of Data Structured passed by argument
    EDGES_KEY = &#39;arestas&#39;
    # Graph name Key of Data Structured passed by argument
    GRAPH_NAME_KEY = &#39;nome&#39;
    
    def __init__(self, graph = None, directed = False):
        &#34;&#34;&#34;Default Constructor
        
        Keyword Arguments:
            graph {Dictionary}  -- Data Structure to Initialize the Graph with. Example: {Name: Graph_Name, Vertices: [Array of Vertices], Edges[Array of Edges]} (default: {None})
            directed {bool}     -- Graph is directed (oriented) or Not. (default: {False})
        &#34;&#34;&#34;

        &#34;&#34;&#34;Create public variables to store searchs and max flow algorithms data
        &#34;&#34;&#34;
        self.visited = {}
        self.explored = {}
        self.discovered = {}
        
        self.directed = directed
        
        self.capacity = {}
        
        self.flow = {}
        
        self.sink = {}
        
        self.reverse_edge = {}
        
        &#34;&#34;&#34;Initialize Graph with Data Structure passed by Argument or initialize everything with blank
        &#34;&#34;&#34;
        if graph is not None:
            self.graph = graph
        else:
            self.graph = {}
            self.graph[self.VERTICES_KEY] = []
            self.graph[self.EDGES_KEY] = []
            self.graph[self.GRAPH_NAME_KEY] = []
        
    def show(self):
        &#34;&#34;&#34; Print Current Graph into Console.
        &#34;&#34;&#34;
        print(self.graph)
        
    def getGraph(self):
        &#34;&#34;&#34;Return Original Graph Data Structure ( This method is not public as it is overriden by child classes )

        **Overriden Method by Child**
        
        Returns:
            Dictionary -- Return initial Graph Data Structure
        &#34;&#34;&#34;
        return self.graph
        
    def getVertices(self):
        &#34;&#34;&#34; Get Graph&#39;s Vertices List

        **Overriden Method by Child**
        
        Returns:
            [List]     -- Vertices List
        &#34;&#34;&#34;
        return self.graph[self.VERTICES_KEY]
        
    def verticesCount(self):
        &#34;&#34;&#34;Count Number of Vertices
        
        Returns:
            [Integer]   -- Number of Vertices
        &#34;&#34;&#34;
        return len(self.getVertices())
        
    def getEdges(self):
        &#34;&#34;&#34;Get Graph&#39;s Edges List

        **Overriden Method by Child**
        
        Returns:
            [List]      -- Edges List
        &#34;&#34;&#34;
        return self.graph[self.EDGES_KEY]
        
    def edgesCount(self):
        &#34;&#34;&#34;Count Number of Edges
        
        Returns:
            [Integer]   -- Number of Edges
        &#34;&#34;&#34;
        return len(self.getEdges())
        
    def getName(self):
        &#34;&#34;&#34;Get Graph&#39;s Name
        
        Returns:
            [String]        -- Graph&#39;s Name
        &#34;&#34;&#34;
        return self.graph[self.GRAPH_NAME_KEY]
        
    def setName(self, name):
        &#34;&#34;&#34;Define Graph&#39;s Name
        
        Arguments:
            name {String}    -- Graph&#39;s Name
        &#34;&#34;&#34;
        self.graph[self.GRAPH_NAME_KEY] = name
        
    def verticeExists(self, vertice):
        &#34;&#34;&#34;Check if Vertice Exists

        **Overriden Method by Child**
        
        Arguments:
            vertice {String|Integer}  -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            [Boolean]         -- Condition to check if vertice exists
        &#34;&#34;&#34;
        return vertice in self.graph[self.VERTICES_KEY]
        
    def edgeExists(self, edge):
        &#34;&#34;&#34;Check if Edges Exists

        **Overriden Method by Child**
        
        Arguments:
            edge {List}       -- Edges as List. Example: [vertice1, vertice2]
        
        Returns:
            Boolean           -- Either Edge Exists or Not.
        &#34;&#34;&#34;
        
        v1 = edge[0]
        v2 = edge[1]
        
        return [v1, v2] in self.graph[self.EDGES_KEY] or [v2, v1] in self.graph[self.EDGES_KEY]
        
    def createVertice(self, vertice):
        &#34;&#34;&#34;Create Vertice in Graph

        **Overriden Method by Child**
        
        Arguments:
            vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Vertice Already Exists in Graph
        &#34;&#34;&#34;
        if (self.verticeExists(vertice) == False):
            self.graph[self.VERTICES_KEY].append(vertice)
            return
        
        raise Exception(&#39;Vertice is already in Graph!&#39;)
        
    def createVertices(self, vertices):
        &#34;&#34;&#34;Create Many Vertices in Graph
        
        Arguments:
            vertices {List}         -- List of Vertices to be created.
        &#34;&#34;&#34;
        for vertice in vertices:
            self.createVertice(vertice)
            
    def createEdge(self, edge):
        &#34;&#34;&#34;Create Edge in Graph

        **Overriden Method by Child**
        
        Arguments:
            edge {List}             -- Edges as List. Example: [vertice1, vertice2]
        
        Raises:
            Exception: Edge already Exists in Graph
        &#34;&#34;&#34;
        if (self.edgeExists(edge) == False):
            self.graph[self.EDGES_KEY].append(edge)
            return
        
        raise Exception(&#39;Edge is already in Graph!&#39;)
        
    def removeEdge(self, edge):
        &#34;&#34;&#34;Remove Edge from Graph

        **Overriden Method by Child**
        
        Arguments:
            edge {List}         -- Edges as List. Example: [vertice1, vertice2]
        
        Raises:
            Exception: Edge doesn&#39;t Exists in Graph
        &#34;&#34;&#34;
        if (self.edgeExists(edge)):
            del self.graph[self.EDGES_KEY][edge]
            return
        
        raise Exception(&#39;Edge not Found in Graph!&#39;)

    def removeVertice(self, vertice):
        &#34;&#34;&#34;Remove Vertice from Graph
        
        Arguments:
            vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Method not Implemented!
        &#34;&#34;&#34;
        
        raise Exception(&#39;removeVertice(self,vertice) is not Implemented!&#39;)
        
    def clearEdges(self):
        &#34;&#34;&#34;Remove all Edges from Graphs
        &#34;&#34;&#34;
        for edge in list(self.getEdges().values()):
            self.removeEdge(edge)
        
    def getSymbolicEdge(self, firstVertice, secondVertice):
        &#34;&#34;&#34;Get Symbolic Edge as String. Example: firstVertice: 0 and secondVertice: 1 turns to &#39;01&#39;
           So it can be used as Dictionary Key
        
        Arguments:
            firstVertice {String|Integer}         -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            secondVertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            [String]                              -- Symbolic Key of Vertices as String. Example: firstVertice: 0 and secondVertice: 1 turns to &#39;01&#39;
        &#34;&#34;&#34;
        return str(firstVertice) + str(secondVertice)
        
    def initializeEdge(self, edge):
        &#34;&#34;&#34;Initialize Edge with default Setup such as explored, discovered to default values as they are global
           Similar To: initializeVertice(self, vertice)
        
        Arguments:
            edge {List}                           -- Edges as List. Example: [vertice1, vertice2]
        &#34;&#34;&#34;
        symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
        
        self.explored[symbolic_edge] = False
        
        self.discovered[symbolic_edge] = False
        
        self.createFlow(edge, 0)
        
        self.createCapacity(edge, 0)
        
        self.sink[symbolic_edge] = False
    
        if (self.directed == False):
            inversed_symbolic_edge = self.getSymbolicEdge(edge[1], edge[0])
            self.explored[inversed_symbolic_edge] = False
            self.discovered[inversed_symbolic_edge] = False
    
    def initializeVertice(self, vertice):
        &#34;&#34;&#34;Initialize Vertice with default setup such as Visited to default values as they are global
           Similar To: initializeEdge(self, edge)
        
        Arguments:
            vertice {String|Integer}            -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        &#34;&#34;&#34;
        self.visited[vertice] = False
        
    def exploreEdge(self, firstVertice, secondVertice):
        &#34;&#34;&#34;Method to Explore Edge
        
        Arguments:
            firstVertice {String|Integer}       -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            secondVertice {String|Integer}      -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        &#34;&#34;&#34;
        self.explored[self.getSymbolicEdge(firstVertice, secondVertice)] = True
        
        if (self.directed == False):
            self.explored[self.getSymbolicEdge(secondVertice, firstVertice)] = True
        
    def discoverEdge(self, firstVertice, secondVertice):
        &#34;&#34;&#34;Method to Discover Edge
        
        Arguments:
            firstVertice {String|Integer}       -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            secondVertice {String|Integer}      -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        &#34;&#34;&#34;
        self.discovered[self.getSymbolicEdge(firstVertice, secondVertice)] = True
        
        if (self.directed == False):
            self.discovered[self.getSymbolicEdge(secondVertice, firstVertice)] = True
        
    def createCapacity(self, edge, capacity = 0):
        &#34;&#34;&#34;Creates Capacity for Edge
        
        Arguments:
            edge {List}         -- Edges as List. Example: [vertice1, vertice2]
        
        Keyword Arguments:
            capacity {int}      -- Capacity Value for Edge (default: {0})
        
        Returns:
            Boolean             -- Capacity was created or not
        &#34;&#34;&#34;
        if self.edgeExists(edge):
            self.capacity[self.getSymbolicEdge(edge[0], edge[1])] = capacity
            return True
            
        return False
        
    def createFlow(self, edge, flow = 0):
        &#34;&#34;&#34;Creates Flow for Edge
        
        Arguments:
            edge {List}         -- Edges as List. Example: [vertice1, vertice2]
        
        Keyword Arguments:
            flow {int}          -- Flow Value for Edge (default: {0})
        
        Returns:
            Boolean             -- Flow was created or not
        &#34;&#34;&#34;
        if self.edgeExists(edge):
            self.flow[self.getSymbolicEdge(edge[0], edge[1])] = flow
            return True
            
        return False
        
    def resetState(self):
        &#34;&#34;&#34;Reset State for the Graph. Basically resets global variables to default value

           Values reseted: visited, sink, discovered, expored, reverse_edge, flow, capacity
        &#34;&#34;&#34;
        for vertice in self.visited:
            self.visited[vertice] = False
            
        for sink in self.sink:
            self.sink[sink] = False
            
        for discovered in self.discovered:
            self.discovered[discovered] = False
            
        for explored in self.explored:
            self.explored[explored] = False
            
        for reverse in self.reverse_edge:
            self.reverse_edge[reverse] = 0
            
        for flow in self.flow:
            self.flow[flow] = 0
            
        for capacity in self.capacity:
            self.capacity[capacity] = 0
    
    def fullSearch(self):
        &#34;&#34;&#34;Full Search Method for Graph, performs search in every Vertice in Graph.
           Visiting, Exploring and Discovering Every Vertice and Edge in Graph.
           Complexity: Î¸(n+m)
        &#34;&#34;&#34;
        for vertice in self.getVertices():
            if(self.visited[vertice] == False):
                self.search(vertice)
        
    def search(self, vertice = None):
        &#34;&#34;&#34;Search Method for Graph, performs Search initializing from a random or choosen vertice.
           Visiting, Exploring and Discovering Every Vertice and Edge in Graph.
           Complexity: O(n+m)
        
        Keyword Arguments:
            vertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive. (default: {None})
        &#34;&#34;&#34;
        if vertice is None:
            # Choosing Randomly Doesn&#39;t Work so instead choose the first one
            # root_vertice = random.choices(list(self.list_graph.keys()), k=1)
            root_vertice = list(self.getVertices())
            self.visited[root_vertice[0]] = True
        else:
            self.visited[vertice] = True
            
        for edge in list(self.getEdges().values()):
            symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
            if (self.visited[edge[0]] and not self.explored[symbolic_edge]):
                self.explored[symbolic_edge] = True
                
                if not self.visited[edge[1]]:
                    self.visited[edge[1]], self.discovered[symbolic_edge] = True, True
        
    def isConnected(self):
        &#34;&#34;&#34;Check if Graph is Connected or Not
           Complexity: O(n+m)
        
        Returns:
            Boolean         -- Graph is Connected or Not
        &#34;&#34;&#34;
        self.search()
        for vertice in self.getVertices():
            if(self.visited[vertice] == False):
                return False
        return True
        
    def hasCicle(self):
        &#34;&#34;&#34;Check if Graph has Cicle or Not
           Complexity: O(n+m)
        Returns:
            Boolean         -- Graph has Cicle or Not
        &#34;&#34;&#34;
        self.fullSearch()
        
        for edge in self.getEdges().keys():
            if not self.discovered[edge]:
                return True
        return False
        
    def hasForest(self):
        &#34;&#34;&#34;Check if Graph has Forest or Not
           Complexity: O(n+m)
        
        Returns:
            Boolean         -- Graph has a Forest or Not
        &#34;&#34;&#34;
        return not self.hasCicle() 
    
    def isTree(self, alternative = False):
        &#34;&#34;&#34;Check if Graph is a Tree or Not
           Complexity: O(n+m) 

        Keyword Arguments:
            alternative {bool}  -- Use Alternative Method to Verify if Is Tree. First uses Search and Second Uses isConnected() and not HasCicle()  (default: {False})
        
        Returns:
            Boolean             -- Graph is a Tree or Not
        &#34;&#34;&#34;
        
        if not alternative:
            self.search()
            
            for vertice in self.getVertices():
                if(self.visited[vertice] == False):
                    return False
            
            for edge in list(self.getEdges().values()):
                symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
                if(self.discovered[symbolic_edge] == False):
                    return False
        else:
            return self.isConnected() and not self.hasCicle()

        return True
    
    def getForestGeneratorGraph(self):
        &#34;&#34;&#34;Get Forest Generator Graph
           Complexity: O(n+m) 
        
        Returns:
            Graph       -- Returns Forest Generator Graph for the current Graph itself
        &#34;&#34;&#34;
        
        newGraph = self.getGraphInstance(directed = self.directed)
        
        newGraph.createVertices(self.getVertices())

        self.fullSearch()
        
        for edge in list(self.getEdges().values()):
            symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
            if self.discovered[symbolic_edge]:
                newGraph.createEdge(edge)
                
        return newGraph
    
    
    def depthSearch(self, vertice, recursive = False):
        &#34;&#34;&#34;Peforms Depth Search in Graph either on Recursive or Iterative Mode
        
        Arguments:
            vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Keyword Arguments:
            recursive {bool}            -- Execute using recursive method or iterative (default: {False})
        &#34;&#34;&#34;

        self.visited[vertice] = True
        
        if(recursive):
            for neighborhoodVertice in self.getVerticeNeighborhood(vertice):
                if(self.visited[neighborhoodVertice]):
                    if not self.explored[self.getSymbolicEdge(vertice, neighborhoodVertice)]:
                        self.exploreEdge(vertice, neighborhoodVertice)
                else:
                    self.exploreEdge(vertice, neighborhoodVertice)
                    self.discoverEdge(vertice, neighborhoodVertice)
                    self.depthSearch(neighborhoodVertice, True)
        else:
            stack = []
            stack.append([vertice, self.getVerticeNeighborhoodAfter(vertice)])

            while(stack):
                topStack = stack.pop()
                vertice = topStack[0]
                nextNeighborhoodVertice = topStack[1]

                if(nextNeighborhoodVertice &gt; 0):
                    stack.append([vertice,self.getVerticeNeighborhoodAfter(vertice,nextNeighborhoodVertice)])
                   
                    if(self.visited[nextNeighborhoodVertice]):
                        if(not self.explored[self.getSymbolicEdge(vertice, nextNeighborhoodVertice)]):
                            self.exploreEdge(vertice, nextNeighborhoodVertice)
                    else:
                        self.exploreEdge(vertice, nextNeighborhoodVertice)
                        self.discoverEdge(vertice, nextNeighborhoodVertice)
                        self.visited[nextNeighborhoodVertice] = True
                        stack.append([nextNeighborhoodVertice, self.getVerticeNeighborhoodAfter(nextNeighborhoodVertice)])
                    
    def getVerticeNeighborhoodAfter(self, vertice, neighborhoodVertice = None):
        &#34;&#34;&#34;Get Vertices Neighborhood of a Vertice after some Vertice Neighborhood.
           Example: Vertices neighborhood for v1 is [v2,v3,v4]
                    neighborhoodVertice value is v3 then result will be v4. 
        
        Arguments:
            vertice {String|Integer}                -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Keyword Arguments:
            neighborhoodVertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive. (default: {None})
        
        Returns:
            List        -- List of Vertices Neighborhood after a given vertice inside the neighborhood
        &#34;&#34;&#34;
        
        verticeNeighborhoodList = self.getVerticeNeighborhood(vertice)
        
        if not verticeNeighborhoodList:
            return 0
        else:
            if(neighborhoodVertice is None):
                return verticeNeighborhoodList[0]
        
        indexAfter = verticeNeighborhoodList.index(neighborhoodVertice)+1
        try:
            if(verticeNeighborhoodList[indexAfter]):
                return verticeNeighborhoodList[indexAfter]
        except IndexError:  
            return 0

    def breadthStartSearch(self, start_vertice):
        &#34;&#34;&#34;Performs Breadth Search in Graph
        
        Arguments:
            start_vertice {String|Integer}      -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        &#34;&#34;&#34;
        
        self.visited[start_vertice] = True
        queue = deque([])
        queue.append(start_vertice)

        while(queue):
            vertice = queue.popleft()
            for neighborhoodVertice in self.getVerticeNeighborhood(vertice):
                if(self.visited[neighborhoodVertice]):
                    if(not self.explored[self.getSymbolicEdge(vertice, neighborhoodVertice)]):
                        self.exploreEdge(vertice, neighborhoodVertice)
                else:
                    self.exploreEdge(vertice, neighborhoodVertice)
                    self.discoverEdge(vertice, neighborhoodVertice)
                    self.visited[neighborhoodVertice] = True
                    queue.append(neighborhoodVertice)
                    
    def breadthStartToEndSearch(self, start_vertice, end_vertice):
        &#34;&#34;&#34;Performs Breadth Search from a Start Vertice to an Destination Veretice
           From Vertice A to B it will return a Graph with at least one path between those two points.
        
        Arguments:
            start_vertice {String|Integer}  -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            end_vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            Graph   -- Graph with at least one Path that exists from origin vertice to destination vertice
        &#34;&#34;&#34;

        self.visited[start_vertice] = True
        queue = deque([])
        queue.append(start_vertice)
        
        graph = self.getGraphInstance(directed = self.directed)

        graph.createVertice(start_vertice)
   
        while(queue):
            vertice = queue.popleft()
            for neighborhoodVertice in self.getVerticeNeighborhood(vertice):
                
                if(self.visited[neighborhoodVertice]):
                    if not self.explored[self.getSymbolicEdge(vertice, neighborhoodVertice)]:
                        self.exploreEdge(vertice, neighborhoodVertice)
                        graph.createEdge([vertice, neighborhoodVertice])
                else:
                    self.exploreEdge(vertice, neighborhoodVertice)
                    self.discoverEdge(vertice, neighborhoodVertice)
                    self.visited[neighborhoodVertice] = True
                    queue.append(neighborhoodVertice)
                    graph.createVertice(neighborhoodVertice)
                    graph.createEdge([vertice, neighborhoodVertice])
                    
                if (neighborhoodVertice == end_vertice):
                    return graph
            
        return None
    
    def getGraphPaths(self, origin_vertice, destination_vertice):
        &#34;&#34;&#34;Get All Paths from one Origin Vertice to a Destination Vertice
           From Vertice A to B returns a List of Graphs containing all Paths between those two Vertices
           
           Related To: getAllGraphPaths()
        
        Arguments:
            origin_vertice {String|Integer}             -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            destination_vertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            [List]      -- List of Graph&#39;s Paths
        &#34;&#34;&#34;

        paths = []
        
        graphs_paths = []
        
        visited = {}

        for vertice in self.getVertices():
            visited[vertice] = False
        
        self.getAllGraphPaths(origin_vertice, destination_vertice, visited, paths, graphs_paths)
        
        return graphs_paths
    
    def getAllGraphPaths(self, origin_vertice, destination_vertice, visited, paths, graphs_paths):
        &#34;&#34;&#34;Get All Paths from one Origin Vertice to a Destination Vertice
           From Vertice A to B returns a List of Graphs containing all Paths between those two Vertices
        
        Arguments:
            origin_vertice {String|Integer}                 -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            destination_vertice {String|Integer}            -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            visited {List}                                  -- Visited List of Vertices ( Passed by Reference )
            paths {List}                                    -- List of Paths ( Passed by Reference )
            graphs_paths {List}                             -- List of Graph&#39;s Paths ( Passed by Reference )
        &#34;&#34;&#34;
  
        # Mark the current node as visited and store in path 
        visited[origin_vertice] = True
        paths.append(origin_vertice) 
  
        # If current vertex is same as destination, then print 
        # current path[] 
        if (origin_vertice == destination_vertice):
            
            graph = self.getGraphInstance(directed = self.directed)
            
            index = 0
            
            for i in range(len(paths)):
                
                vertice = paths[i]
                
                if not graph.verticeExists(vertice):
                    graph.createVertice(vertice)
                
                if (i &lt; len(paths) - 1):
                    
                    next_vertice = paths[i + 1]
                    
                    if not graph.verticeExists(next_vertice):
                        graph.createVertice(next_vertice)
                    
                    graph.createEdge([vertice, next_vertice])
                    
            graphs_paths.append(graph)
        else: 
            # If current vertex is not destination 
            #Recur for all the vertices adjacent to this vertex 
            for neighborhoodVertice in self.getVerticeNeighborhood(origin_vertice): 
                if (visited[neighborhoodVertice] == False): 
                    self.getAllGraphPaths(neighborhoodVertice, destination_vertice, visited, paths, graphs_paths) 
                      
        # Remove current vertex from path[] and mark it as unvisited 
        paths.pop()
        
        visited[origin_vertice] = False
    
    def distancesToVertice(self, vertice):
        &#34;&#34;&#34;Get All Vertice Distances to One Specified Vertice
           Example: distancesToVertice(1) -&gt; Returns a List of All Vertices and their distances to Vertice 1
        
        Arguments:
            vertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            [List]      -- List of Vertices containing their Distances
        &#34;&#34;&#34;
        
        distances = {}
        
        for _vertice in self.getVertices():
            distances[_vertice] = None
        
        queue = deque([])
        
        self.visited[vertice] = True
        
        queue.append([vertice, 1])
        
        while(len(queue) &gt; 0):
            popedEdge = queue.popleft()
            
            for neighborhoodVertice in self.getVerticeNeighborhood(popedEdge[0]):
                if self.visited[neighborhoodVertice]:
                    if not self.explored[self.getSymbolicEdge(popedEdge[0], neighborhoodVertice)]:
                        self.exploreEdge(popedEdge[0], neighborhoodVertice)
                else:
                    self.exploreEdge(popedEdge[0], neighborhoodVertice)
                    self.discoverEdge(popedEdge[0], neighborhoodVertice)
                    
                    self.visited[neighborhoodVertice] = True
                    
                    distances[neighborhoodVertice] = popedEdge[1]
    
                    queue.append([neighborhoodVertice, popedEdge[1] + 1])
                    
        return distances
        
    def getMaxFlow(self, source, sink):
        &#34;&#34;&#34;Get Max Flow from a Directed Graph
           Related To: getResidualGraph()
        
        Arguments:
            source {String|Integer}         -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            sink {String|Integer}           -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Graph is not Directed!
        
        Returns:
            Integer         -- Value of Max Flow
        &#34;&#34;&#34;
        
        if (self.directed == False):
            raise Exception(&#39;Current Graph is not Directed! Transform it to Directed Graph to use MaxFlow!&#39;)
        
        #flow = {}
        
        max_flow_digraph = 0
        
        for edge in list(self.getEdges().values()):
            self.flow[self.getSymbolicEdge(edge[0], edge[1])] = 0
            
        residual_digraph = self.getResidualGraph(source, sink)
        
        try:
            residual_possible_paths = residual_digraph.breadthStartToEndSearch(source, sink).getGraphPaths(source, sink)
        except AttributeError:  
            return 0
        
        # residual_possible_paths = residual_digraph.getGraphPaths(source, sink)
        
        digraph_path = random.choice(residual_possible_paths)
        
        residual_capacity = 0
        
        while (digraph_path != None):
            
            residual_capacity = min(list(self.reverse_edge.values()))
            
            max_flow_digraph += residual_capacity
            
            for edge in list(digraph_path.getEdges().values()):
                
                symbolic_edge = digraph_path.getSymbolicEdge(edge[0], edge[1])
                
                inverse_symbolic_edge = digraph_path.getSymbolicEdge(edge[1], edge[0])
                
                if (self.sink[symbolic_edge]):
                    self.flow[symbolic_edge] += residual_capacity
                else:
                    self.flow[inverse_symbolic_edge] -= residual_capacity
                    
            residual_digraph = self.getResidualGraph(source, sink)
            
            # possible_digraph_paths = residual_digraph.getGraphPaths(source, sink)
            possible_paths = residual_digraph.breadthStartToEndSearch(source, sink)
            
            if possible_paths is not None:
                digraph_path = random.choice(possible_paths.getGraphPaths(source, sink))
            else:
                digraph_path = None
            
            # if possible_digraph_paths:
            #    digraph_path = random.choice(possible_digraph_paths)
            #else:
            #    digraph_path = None
            
        return max_flow_digraph
    
    def getResidualGraph(self, source, sink):
        &#34;&#34;&#34;Get Residual Graph for MaxFlow usage
           Related To: MaxFlow()
        
        Arguments:
            source {String|Integer}         -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            sink {String|Integer}           -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Graph is not Directed!
        
        Returns:
            Graph       -- Residual Generated Graph
        &#34;&#34;&#34;
        
        if (self.directed == False):
            raise Exception(&#39;Current Graph is not Directed! Transform it to Directed Graph to use ResidualGraph!&#39;)
        
        residual_digraph = self.getGraphInstance(deep_copy = True)
        
        residual_digraph.clearEdges()
        
        for edge in list(self.getEdges().values()):
            
            symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
            
            reverse_symbolic_edge = self.getSymbolicEdge(edge[1], edge[0])
            
            if (self.capacity[symbolic_edge] - self.flow[symbolic_edge]) &gt; 0:
                residual_digraph.createEdge(edge)
                self.reverse_edge[symbolic_edge] = self.capacity[symbolic_edge] - self.flow[symbolic_edge]
                self.sink[symbolic_edge] = True
            elif (self.flow[symbolic_edge] &gt; 0):
                residual_digraph.createEdge([edge[1], edge[0]])
                self.reverse_edge[reverse_symbolic_edge] = self.flow[symbolic_edge]
                self.sink[reverse_symbolic_edge] = False
                
        return residual_digraph
                
    
    def getVerticeNeighborhood(self, vertice):
        &#34;&#34;&#34;Get All Vertices in a Vertice(V1) Neighborhood
           Example: v1 has [v2,v3,v4] as adjacency vertices, this methods returns those vertices
        
        Arguments:
            vertice {String|Vertice}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Method Not Implemented in Child Class!
        &#34;&#34;&#34;
        raise Exception(&#39;getVerticeNeighborhood(vertice) Not Implemented! You need to Implement this method in your class!&#39;)
        
    def getGraphInstance(self, deep_copy = False, directed = False):
        &#34;&#34;&#34;Get Self Graph Instance as a Copy or New One

           **Method Overriden by Child Class**
        
        Keyword Arguments:
            deep_copy {bool}    -- Generate a new copy of itself or a new one (default: {False})
            directed {bool}     -- If New Graph should be Directed or Not (default: {False})
        
        Raises:
            Exception: Method not Implemented
        &#34;&#34;&#34;
        raise Exception(&#39;graphInstance() Not Implemented! You need to Implement in your class simply returning its self new instance&#39;)
        
        
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="python-graphs.modules.graph.graph.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>graph=None, directed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Generic Class for Graphs. It shares common methods for data representations implementations such as AdjacencyList and AdjacencyMatrix.</p>
<p>All basic methods to interact with Vertice and Edges needs to be override by the Child Class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> &ndash; <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> <code>Class</code></dt>
<dd>&nbsp;</dd>
<dt><code>Default</code> <code>Constructor</code></dt>
<dd>&nbsp;</dd>
<dt><code>Keyword</code> <code>Arguments</code>:</dt>
<dd>graph {Dictionary}
&ndash; Data Structure to Initialize the Graph with. Example: {Name: Graph_Name, Vertices: [Array of Vertices], Edges[Array of Edges]} (default: {None})
directed {bool}
&ndash; Graph is directed (oriented) or Not. (default: {False})</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Graph:
    &#34;&#34;&#34;
    Generic Class for Graphs. It shares common methods for data representations implementations such as AdjacencyList and AdjacencyMatrix.

    All basic methods to interact with Vertice and Edges needs to be override by the Child Class.

    Returns:
        Graph -- Graph Class
    &#34;&#34;&#34;

    # Vertice Key of Data Structured passed by argument
    VERTICES_KEY = &#39;vertices&#39;
    # Edge Key of Data Structured passed by argument
    EDGES_KEY = &#39;arestas&#39;
    # Graph name Key of Data Structured passed by argument
    GRAPH_NAME_KEY = &#39;nome&#39;
    
    def __init__(self, graph = None, directed = False):
        &#34;&#34;&#34;Default Constructor
        
        Keyword Arguments:
            graph {Dictionary}  -- Data Structure to Initialize the Graph with. Example: {Name: Graph_Name, Vertices: [Array of Vertices], Edges[Array of Edges]} (default: {None})
            directed {bool}     -- Graph is directed (oriented) or Not. (default: {False})
        &#34;&#34;&#34;

        &#34;&#34;&#34;Create public variables to store searchs and max flow algorithms data
        &#34;&#34;&#34;
        self.visited = {}
        self.explored = {}
        self.discovered = {}
        
        self.directed = directed
        
        self.capacity = {}
        
        self.flow = {}
        
        self.sink = {}
        
        self.reverse_edge = {}
        
        &#34;&#34;&#34;Initialize Graph with Data Structure passed by Argument or initialize everything with blank
        &#34;&#34;&#34;
        if graph is not None:
            self.graph = graph
        else:
            self.graph = {}
            self.graph[self.VERTICES_KEY] = []
            self.graph[self.EDGES_KEY] = []
            self.graph[self.GRAPH_NAME_KEY] = []
        
    def show(self):
        &#34;&#34;&#34; Print Current Graph into Console.
        &#34;&#34;&#34;
        print(self.graph)
        
    def getGraph(self):
        &#34;&#34;&#34;Return Original Graph Data Structure ( This method is not public as it is overriden by child classes )

        **Overriden Method by Child**
        
        Returns:
            Dictionary -- Return initial Graph Data Structure
        &#34;&#34;&#34;
        return self.graph
        
    def getVertices(self):
        &#34;&#34;&#34; Get Graph&#39;s Vertices List

        **Overriden Method by Child**
        
        Returns:
            [List]     -- Vertices List
        &#34;&#34;&#34;
        return self.graph[self.VERTICES_KEY]
        
    def verticesCount(self):
        &#34;&#34;&#34;Count Number of Vertices
        
        Returns:
            [Integer]   -- Number of Vertices
        &#34;&#34;&#34;
        return len(self.getVertices())
        
    def getEdges(self):
        &#34;&#34;&#34;Get Graph&#39;s Edges List

        **Overriden Method by Child**
        
        Returns:
            [List]      -- Edges List
        &#34;&#34;&#34;
        return self.graph[self.EDGES_KEY]
        
    def edgesCount(self):
        &#34;&#34;&#34;Count Number of Edges
        
        Returns:
            [Integer]   -- Number of Edges
        &#34;&#34;&#34;
        return len(self.getEdges())
        
    def getName(self):
        &#34;&#34;&#34;Get Graph&#39;s Name
        
        Returns:
            [String]        -- Graph&#39;s Name
        &#34;&#34;&#34;
        return self.graph[self.GRAPH_NAME_KEY]
        
    def setName(self, name):
        &#34;&#34;&#34;Define Graph&#39;s Name
        
        Arguments:
            name {String}    -- Graph&#39;s Name
        &#34;&#34;&#34;
        self.graph[self.GRAPH_NAME_KEY] = name
        
    def verticeExists(self, vertice):
        &#34;&#34;&#34;Check if Vertice Exists

        **Overriden Method by Child**
        
        Arguments:
            vertice {String|Integer}  -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            [Boolean]         -- Condition to check if vertice exists
        &#34;&#34;&#34;
        return vertice in self.graph[self.VERTICES_KEY]
        
    def edgeExists(self, edge):
        &#34;&#34;&#34;Check if Edges Exists

        **Overriden Method by Child**
        
        Arguments:
            edge {List}       -- Edges as List. Example: [vertice1, vertice2]
        
        Returns:
            Boolean           -- Either Edge Exists or Not.
        &#34;&#34;&#34;
        
        v1 = edge[0]
        v2 = edge[1]
        
        return [v1, v2] in self.graph[self.EDGES_KEY] or [v2, v1] in self.graph[self.EDGES_KEY]
        
    def createVertice(self, vertice):
        &#34;&#34;&#34;Create Vertice in Graph

        **Overriden Method by Child**
        
        Arguments:
            vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Vertice Already Exists in Graph
        &#34;&#34;&#34;
        if (self.verticeExists(vertice) == False):
            self.graph[self.VERTICES_KEY].append(vertice)
            return
        
        raise Exception(&#39;Vertice is already in Graph!&#39;)
        
    def createVertices(self, vertices):
        &#34;&#34;&#34;Create Many Vertices in Graph
        
        Arguments:
            vertices {List}         -- List of Vertices to be created.
        &#34;&#34;&#34;
        for vertice in vertices:
            self.createVertice(vertice)
            
    def createEdge(self, edge):
        &#34;&#34;&#34;Create Edge in Graph

        **Overriden Method by Child**
        
        Arguments:
            edge {List}             -- Edges as List. Example: [vertice1, vertice2]
        
        Raises:
            Exception: Edge already Exists in Graph
        &#34;&#34;&#34;
        if (self.edgeExists(edge) == False):
            self.graph[self.EDGES_KEY].append(edge)
            return
        
        raise Exception(&#39;Edge is already in Graph!&#39;)
        
    def removeEdge(self, edge):
        &#34;&#34;&#34;Remove Edge from Graph

        **Overriden Method by Child**
        
        Arguments:
            edge {List}         -- Edges as List. Example: [vertice1, vertice2]
        
        Raises:
            Exception: Edge doesn&#39;t Exists in Graph
        &#34;&#34;&#34;
        if (self.edgeExists(edge)):
            del self.graph[self.EDGES_KEY][edge]
            return
        
        raise Exception(&#39;Edge not Found in Graph!&#39;)

    def removeVertice(self, vertice):
        &#34;&#34;&#34;Remove Vertice from Graph
        
        Arguments:
            vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Method not Implemented!
        &#34;&#34;&#34;
        
        raise Exception(&#39;removeVertice(self,vertice) is not Implemented!&#39;)
        
    def clearEdges(self):
        &#34;&#34;&#34;Remove all Edges from Graphs
        &#34;&#34;&#34;
        for edge in list(self.getEdges().values()):
            self.removeEdge(edge)
        
    def getSymbolicEdge(self, firstVertice, secondVertice):
        &#34;&#34;&#34;Get Symbolic Edge as String. Example: firstVertice: 0 and secondVertice: 1 turns to &#39;01&#39;
           So it can be used as Dictionary Key
        
        Arguments:
            firstVertice {String|Integer}         -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            secondVertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            [String]                              -- Symbolic Key of Vertices as String. Example: firstVertice: 0 and secondVertice: 1 turns to &#39;01&#39;
        &#34;&#34;&#34;
        return str(firstVertice) + str(secondVertice)
        
    def initializeEdge(self, edge):
        &#34;&#34;&#34;Initialize Edge with default Setup such as explored, discovered to default values as they are global
           Similar To: initializeVertice(self, vertice)
        
        Arguments:
            edge {List}                           -- Edges as List. Example: [vertice1, vertice2]
        &#34;&#34;&#34;
        symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
        
        self.explored[symbolic_edge] = False
        
        self.discovered[symbolic_edge] = False
        
        self.createFlow(edge, 0)
        
        self.createCapacity(edge, 0)
        
        self.sink[symbolic_edge] = False
    
        if (self.directed == False):
            inversed_symbolic_edge = self.getSymbolicEdge(edge[1], edge[0])
            self.explored[inversed_symbolic_edge] = False
            self.discovered[inversed_symbolic_edge] = False
    
    def initializeVertice(self, vertice):
        &#34;&#34;&#34;Initialize Vertice with default setup such as Visited to default values as they are global
           Similar To: initializeEdge(self, edge)
        
        Arguments:
            vertice {String|Integer}            -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        &#34;&#34;&#34;
        self.visited[vertice] = False
        
    def exploreEdge(self, firstVertice, secondVertice):
        &#34;&#34;&#34;Method to Explore Edge
        
        Arguments:
            firstVertice {String|Integer}       -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            secondVertice {String|Integer}      -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        &#34;&#34;&#34;
        self.explored[self.getSymbolicEdge(firstVertice, secondVertice)] = True
        
        if (self.directed == False):
            self.explored[self.getSymbolicEdge(secondVertice, firstVertice)] = True
        
    def discoverEdge(self, firstVertice, secondVertice):
        &#34;&#34;&#34;Method to Discover Edge
        
        Arguments:
            firstVertice {String|Integer}       -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            secondVertice {String|Integer}      -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        &#34;&#34;&#34;
        self.discovered[self.getSymbolicEdge(firstVertice, secondVertice)] = True
        
        if (self.directed == False):
            self.discovered[self.getSymbolicEdge(secondVertice, firstVertice)] = True
        
    def createCapacity(self, edge, capacity = 0):
        &#34;&#34;&#34;Creates Capacity for Edge
        
        Arguments:
            edge {List}         -- Edges as List. Example: [vertice1, vertice2]
        
        Keyword Arguments:
            capacity {int}      -- Capacity Value for Edge (default: {0})
        
        Returns:
            Boolean             -- Capacity was created or not
        &#34;&#34;&#34;
        if self.edgeExists(edge):
            self.capacity[self.getSymbolicEdge(edge[0], edge[1])] = capacity
            return True
            
        return False
        
    def createFlow(self, edge, flow = 0):
        &#34;&#34;&#34;Creates Flow for Edge
        
        Arguments:
            edge {List}         -- Edges as List. Example: [vertice1, vertice2]
        
        Keyword Arguments:
            flow {int}          -- Flow Value for Edge (default: {0})
        
        Returns:
            Boolean             -- Flow was created or not
        &#34;&#34;&#34;
        if self.edgeExists(edge):
            self.flow[self.getSymbolicEdge(edge[0], edge[1])] = flow
            return True
            
        return False
        
    def resetState(self):
        &#34;&#34;&#34;Reset State for the Graph. Basically resets global variables to default value

           Values reseted: visited, sink, discovered, expored, reverse_edge, flow, capacity
        &#34;&#34;&#34;
        for vertice in self.visited:
            self.visited[vertice] = False
            
        for sink in self.sink:
            self.sink[sink] = False
            
        for discovered in self.discovered:
            self.discovered[discovered] = False
            
        for explored in self.explored:
            self.explored[explored] = False
            
        for reverse in self.reverse_edge:
            self.reverse_edge[reverse] = 0
            
        for flow in self.flow:
            self.flow[flow] = 0
            
        for capacity in self.capacity:
            self.capacity[capacity] = 0
    
    def fullSearch(self):
        &#34;&#34;&#34;Full Search Method for Graph, performs search in every Vertice in Graph.
           Visiting, Exploring and Discovering Every Vertice and Edge in Graph.
           Complexity: Î¸(n+m)
        &#34;&#34;&#34;
        for vertice in self.getVertices():
            if(self.visited[vertice] == False):
                self.search(vertice)
        
    def search(self, vertice = None):
        &#34;&#34;&#34;Search Method for Graph, performs Search initializing from a random or choosen vertice.
           Visiting, Exploring and Discovering Every Vertice and Edge in Graph.
           Complexity: O(n+m)
        
        Keyword Arguments:
            vertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive. (default: {None})
        &#34;&#34;&#34;
        if vertice is None:
            # Choosing Randomly Doesn&#39;t Work so instead choose the first one
            # root_vertice = random.choices(list(self.list_graph.keys()), k=1)
            root_vertice = list(self.getVertices())
            self.visited[root_vertice[0]] = True
        else:
            self.visited[vertice] = True
            
        for edge in list(self.getEdges().values()):
            symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
            if (self.visited[edge[0]] and not self.explored[symbolic_edge]):
                self.explored[symbolic_edge] = True
                
                if not self.visited[edge[1]]:
                    self.visited[edge[1]], self.discovered[symbolic_edge] = True, True
        
    def isConnected(self):
        &#34;&#34;&#34;Check if Graph is Connected or Not
           Complexity: O(n+m)
        
        Returns:
            Boolean         -- Graph is Connected or Not
        &#34;&#34;&#34;
        self.search()
        for vertice in self.getVertices():
            if(self.visited[vertice] == False):
                return False
        return True
        
    def hasCicle(self):
        &#34;&#34;&#34;Check if Graph has Cicle or Not
           Complexity: O(n+m)
        Returns:
            Boolean         -- Graph has Cicle or Not
        &#34;&#34;&#34;
        self.fullSearch()
        
        for edge in self.getEdges().keys():
            if not self.discovered[edge]:
                return True
        return False
        
    def hasForest(self):
        &#34;&#34;&#34;Check if Graph has Forest or Not
           Complexity: O(n+m)
        
        Returns:
            Boolean         -- Graph has a Forest or Not
        &#34;&#34;&#34;
        return not self.hasCicle() 
    
    def isTree(self, alternative = False):
        &#34;&#34;&#34;Check if Graph is a Tree or Not
           Complexity: O(n+m) 

        Keyword Arguments:
            alternative {bool}  -- Use Alternative Method to Verify if Is Tree. First uses Search and Second Uses isConnected() and not HasCicle()  (default: {False})
        
        Returns:
            Boolean             -- Graph is a Tree or Not
        &#34;&#34;&#34;
        
        if not alternative:
            self.search()
            
            for vertice in self.getVertices():
                if(self.visited[vertice] == False):
                    return False
            
            for edge in list(self.getEdges().values()):
                symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
                if(self.discovered[symbolic_edge] == False):
                    return False
        else:
            return self.isConnected() and not self.hasCicle()

        return True
    
    def getForestGeneratorGraph(self):
        &#34;&#34;&#34;Get Forest Generator Graph
           Complexity: O(n+m) 
        
        Returns:
            Graph       -- Returns Forest Generator Graph for the current Graph itself
        &#34;&#34;&#34;
        
        newGraph = self.getGraphInstance(directed = self.directed)
        
        newGraph.createVertices(self.getVertices())

        self.fullSearch()
        
        for edge in list(self.getEdges().values()):
            symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
            if self.discovered[symbolic_edge]:
                newGraph.createEdge(edge)
                
        return newGraph
    
    
    def depthSearch(self, vertice, recursive = False):
        &#34;&#34;&#34;Peforms Depth Search in Graph either on Recursive or Iterative Mode
        
        Arguments:
            vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Keyword Arguments:
            recursive {bool}            -- Execute using recursive method or iterative (default: {False})
        &#34;&#34;&#34;

        self.visited[vertice] = True
        
        if(recursive):
            for neighborhoodVertice in self.getVerticeNeighborhood(vertice):
                if(self.visited[neighborhoodVertice]):
                    if not self.explored[self.getSymbolicEdge(vertice, neighborhoodVertice)]:
                        self.exploreEdge(vertice, neighborhoodVertice)
                else:
                    self.exploreEdge(vertice, neighborhoodVertice)
                    self.discoverEdge(vertice, neighborhoodVertice)
                    self.depthSearch(neighborhoodVertice, True)
        else:
            stack = []
            stack.append([vertice, self.getVerticeNeighborhoodAfter(vertice)])

            while(stack):
                topStack = stack.pop()
                vertice = topStack[0]
                nextNeighborhoodVertice = topStack[1]

                if(nextNeighborhoodVertice &gt; 0):
                    stack.append([vertice,self.getVerticeNeighborhoodAfter(vertice,nextNeighborhoodVertice)])
                   
                    if(self.visited[nextNeighborhoodVertice]):
                        if(not self.explored[self.getSymbolicEdge(vertice, nextNeighborhoodVertice)]):
                            self.exploreEdge(vertice, nextNeighborhoodVertice)
                    else:
                        self.exploreEdge(vertice, nextNeighborhoodVertice)
                        self.discoverEdge(vertice, nextNeighborhoodVertice)
                        self.visited[nextNeighborhoodVertice] = True
                        stack.append([nextNeighborhoodVertice, self.getVerticeNeighborhoodAfter(nextNeighborhoodVertice)])
                    
    def getVerticeNeighborhoodAfter(self, vertice, neighborhoodVertice = None):
        &#34;&#34;&#34;Get Vertices Neighborhood of a Vertice after some Vertice Neighborhood.
           Example: Vertices neighborhood for v1 is [v2,v3,v4]
                    neighborhoodVertice value is v3 then result will be v4. 
        
        Arguments:
            vertice {String|Integer}                -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Keyword Arguments:
            neighborhoodVertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive. (default: {None})
        
        Returns:
            List        -- List of Vertices Neighborhood after a given vertice inside the neighborhood
        &#34;&#34;&#34;
        
        verticeNeighborhoodList = self.getVerticeNeighborhood(vertice)
        
        if not verticeNeighborhoodList:
            return 0
        else:
            if(neighborhoodVertice is None):
                return verticeNeighborhoodList[0]
        
        indexAfter = verticeNeighborhoodList.index(neighborhoodVertice)+1
        try:
            if(verticeNeighborhoodList[indexAfter]):
                return verticeNeighborhoodList[indexAfter]
        except IndexError:  
            return 0

    def breadthStartSearch(self, start_vertice):
        &#34;&#34;&#34;Performs Breadth Search in Graph
        
        Arguments:
            start_vertice {String|Integer}      -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        &#34;&#34;&#34;
        
        self.visited[start_vertice] = True
        queue = deque([])
        queue.append(start_vertice)

        while(queue):
            vertice = queue.popleft()
            for neighborhoodVertice in self.getVerticeNeighborhood(vertice):
                if(self.visited[neighborhoodVertice]):
                    if(not self.explored[self.getSymbolicEdge(vertice, neighborhoodVertice)]):
                        self.exploreEdge(vertice, neighborhoodVertice)
                else:
                    self.exploreEdge(vertice, neighborhoodVertice)
                    self.discoverEdge(vertice, neighborhoodVertice)
                    self.visited[neighborhoodVertice] = True
                    queue.append(neighborhoodVertice)
                    
    def breadthStartToEndSearch(self, start_vertice, end_vertice):
        &#34;&#34;&#34;Performs Breadth Search from a Start Vertice to an Destination Veretice
           From Vertice A to B it will return a Graph with at least one path between those two points.
        
        Arguments:
            start_vertice {String|Integer}  -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            end_vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            Graph   -- Graph with at least one Path that exists from origin vertice to destination vertice
        &#34;&#34;&#34;

        self.visited[start_vertice] = True
        queue = deque([])
        queue.append(start_vertice)
        
        graph = self.getGraphInstance(directed = self.directed)

        graph.createVertice(start_vertice)
   
        while(queue):
            vertice = queue.popleft()
            for neighborhoodVertice in self.getVerticeNeighborhood(vertice):
                
                if(self.visited[neighborhoodVertice]):
                    if not self.explored[self.getSymbolicEdge(vertice, neighborhoodVertice)]:
                        self.exploreEdge(vertice, neighborhoodVertice)
                        graph.createEdge([vertice, neighborhoodVertice])
                else:
                    self.exploreEdge(vertice, neighborhoodVertice)
                    self.discoverEdge(vertice, neighborhoodVertice)
                    self.visited[neighborhoodVertice] = True
                    queue.append(neighborhoodVertice)
                    graph.createVertice(neighborhoodVertice)
                    graph.createEdge([vertice, neighborhoodVertice])
                    
                if (neighborhoodVertice == end_vertice):
                    return graph
            
        return None
    
    def getGraphPaths(self, origin_vertice, destination_vertice):
        &#34;&#34;&#34;Get All Paths from one Origin Vertice to a Destination Vertice
           From Vertice A to B returns a List of Graphs containing all Paths between those two Vertices
           
           Related To: getAllGraphPaths()
        
        Arguments:
            origin_vertice {String|Integer}             -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            destination_vertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            [List]      -- List of Graph&#39;s Paths
        &#34;&#34;&#34;

        paths = []
        
        graphs_paths = []
        
        visited = {}

        for vertice in self.getVertices():
            visited[vertice] = False
        
        self.getAllGraphPaths(origin_vertice, destination_vertice, visited, paths, graphs_paths)
        
        return graphs_paths
    
    def getAllGraphPaths(self, origin_vertice, destination_vertice, visited, paths, graphs_paths):
        &#34;&#34;&#34;Get All Paths from one Origin Vertice to a Destination Vertice
           From Vertice A to B returns a List of Graphs containing all Paths between those two Vertices
        
        Arguments:
            origin_vertice {String|Integer}                 -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            destination_vertice {String|Integer}            -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            visited {List}                                  -- Visited List of Vertices ( Passed by Reference )
            paths {List}                                    -- List of Paths ( Passed by Reference )
            graphs_paths {List}                             -- List of Graph&#39;s Paths ( Passed by Reference )
        &#34;&#34;&#34;
  
        # Mark the current node as visited and store in path 
        visited[origin_vertice] = True
        paths.append(origin_vertice) 
  
        # If current vertex is same as destination, then print 
        # current path[] 
        if (origin_vertice == destination_vertice):
            
            graph = self.getGraphInstance(directed = self.directed)
            
            index = 0
            
            for i in range(len(paths)):
                
                vertice = paths[i]
                
                if not graph.verticeExists(vertice):
                    graph.createVertice(vertice)
                
                if (i &lt; len(paths) - 1):
                    
                    next_vertice = paths[i + 1]
                    
                    if not graph.verticeExists(next_vertice):
                        graph.createVertice(next_vertice)
                    
                    graph.createEdge([vertice, next_vertice])
                    
            graphs_paths.append(graph)
        else: 
            # If current vertex is not destination 
            #Recur for all the vertices adjacent to this vertex 
            for neighborhoodVertice in self.getVerticeNeighborhood(origin_vertice): 
                if (visited[neighborhoodVertice] == False): 
                    self.getAllGraphPaths(neighborhoodVertice, destination_vertice, visited, paths, graphs_paths) 
                      
        # Remove current vertex from path[] and mark it as unvisited 
        paths.pop()
        
        visited[origin_vertice] = False
    
    def distancesToVertice(self, vertice):
        &#34;&#34;&#34;Get All Vertice Distances to One Specified Vertice
           Example: distancesToVertice(1) -&gt; Returns a List of All Vertices and their distances to Vertice 1
        
        Arguments:
            vertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Returns:
            [List]      -- List of Vertices containing their Distances
        &#34;&#34;&#34;
        
        distances = {}
        
        for _vertice in self.getVertices():
            distances[_vertice] = None
        
        queue = deque([])
        
        self.visited[vertice] = True
        
        queue.append([vertice, 1])
        
        while(len(queue) &gt; 0):
            popedEdge = queue.popleft()
            
            for neighborhoodVertice in self.getVerticeNeighborhood(popedEdge[0]):
                if self.visited[neighborhoodVertice]:
                    if not self.explored[self.getSymbolicEdge(popedEdge[0], neighborhoodVertice)]:
                        self.exploreEdge(popedEdge[0], neighborhoodVertice)
                else:
                    self.exploreEdge(popedEdge[0], neighborhoodVertice)
                    self.discoverEdge(popedEdge[0], neighborhoodVertice)
                    
                    self.visited[neighborhoodVertice] = True
                    
                    distances[neighborhoodVertice] = popedEdge[1]
    
                    queue.append([neighborhoodVertice, popedEdge[1] + 1])
                    
        return distances
        
    def getMaxFlow(self, source, sink):
        &#34;&#34;&#34;Get Max Flow from a Directed Graph
           Related To: getResidualGraph()
        
        Arguments:
            source {String|Integer}         -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            sink {String|Integer}           -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Graph is not Directed!
        
        Returns:
            Integer         -- Value of Max Flow
        &#34;&#34;&#34;
        
        if (self.directed == False):
            raise Exception(&#39;Current Graph is not Directed! Transform it to Directed Graph to use MaxFlow!&#39;)
        
        #flow = {}
        
        max_flow_digraph = 0
        
        for edge in list(self.getEdges().values()):
            self.flow[self.getSymbolicEdge(edge[0], edge[1])] = 0
            
        residual_digraph = self.getResidualGraph(source, sink)
        
        try:
            residual_possible_paths = residual_digraph.breadthStartToEndSearch(source, sink).getGraphPaths(source, sink)
        except AttributeError:  
            return 0
        
        # residual_possible_paths = residual_digraph.getGraphPaths(source, sink)
        
        digraph_path = random.choice(residual_possible_paths)
        
        residual_capacity = 0
        
        while (digraph_path != None):
            
            residual_capacity = min(list(self.reverse_edge.values()))
            
            max_flow_digraph += residual_capacity
            
            for edge in list(digraph_path.getEdges().values()):
                
                symbolic_edge = digraph_path.getSymbolicEdge(edge[0], edge[1])
                
                inverse_symbolic_edge = digraph_path.getSymbolicEdge(edge[1], edge[0])
                
                if (self.sink[symbolic_edge]):
                    self.flow[symbolic_edge] += residual_capacity
                else:
                    self.flow[inverse_symbolic_edge] -= residual_capacity
                    
            residual_digraph = self.getResidualGraph(source, sink)
            
            # possible_digraph_paths = residual_digraph.getGraphPaths(source, sink)
            possible_paths = residual_digraph.breadthStartToEndSearch(source, sink)
            
            if possible_paths is not None:
                digraph_path = random.choice(possible_paths.getGraphPaths(source, sink))
            else:
                digraph_path = None
            
            # if possible_digraph_paths:
            #    digraph_path = random.choice(possible_digraph_paths)
            #else:
            #    digraph_path = None
            
        return max_flow_digraph
    
    def getResidualGraph(self, source, sink):
        &#34;&#34;&#34;Get Residual Graph for MaxFlow usage
           Related To: MaxFlow()
        
        Arguments:
            source {String|Integer}         -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
            sink {String|Integer}           -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Graph is not Directed!
        
        Returns:
            Graph       -- Residual Generated Graph
        &#34;&#34;&#34;
        
        if (self.directed == False):
            raise Exception(&#39;Current Graph is not Directed! Transform it to Directed Graph to use ResidualGraph!&#39;)
        
        residual_digraph = self.getGraphInstance(deep_copy = True)
        
        residual_digraph.clearEdges()
        
        for edge in list(self.getEdges().values()):
            
            symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
            
            reverse_symbolic_edge = self.getSymbolicEdge(edge[1], edge[0])
            
            if (self.capacity[symbolic_edge] - self.flow[symbolic_edge]) &gt; 0:
                residual_digraph.createEdge(edge)
                self.reverse_edge[symbolic_edge] = self.capacity[symbolic_edge] - self.flow[symbolic_edge]
                self.sink[symbolic_edge] = True
            elif (self.flow[symbolic_edge] &gt; 0):
                residual_digraph.createEdge([edge[1], edge[0]])
                self.reverse_edge[reverse_symbolic_edge] = self.flow[symbolic_edge]
                self.sink[reverse_symbolic_edge] = False
                
        return residual_digraph
                
    
    def getVerticeNeighborhood(self, vertice):
        &#34;&#34;&#34;Get All Vertices in a Vertice(V1) Neighborhood
           Example: v1 has [v2,v3,v4] as adjacency vertices, this methods returns those vertices
        
        Arguments:
            vertice {String|Vertice}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        
        Raises:
            Exception: Method Not Implemented in Child Class!
        &#34;&#34;&#34;
        raise Exception(&#39;getVerticeNeighborhood(vertice) Not Implemented! You need to Implement this method in your class!&#39;)
        
    def getGraphInstance(self, deep_copy = False, directed = False):
        &#34;&#34;&#34;Get Self Graph Instance as a Copy or New One

           **Method Overriden by Child Class**
        
        Keyword Arguments:
            deep_copy {bool}    -- Generate a new copy of itself or a new one (default: {False})
            directed {bool}     -- If New Graph should be Directed or Not (default: {False})
        
        Raises:
            Exception: Method not Implemented
        &#34;&#34;&#34;
        raise Exception(&#39;graphInstance() Not Implemented! You need to Implement in your class simply returning its self new instance&#39;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="python-graphs.modules.graph.graph.Graph.EDGES_KEY"><code class="name">var <span class="ident">EDGES_KEY</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.GRAPH_NAME_KEY"><code class="name">var <span class="ident">GRAPH_NAME_KEY</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.VERTICES_KEY"><code class="name">var <span class="ident">VERTICES_KEY</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="python-graphs.modules.graph.graph.Graph.reverse_edge"><code class="name">var <span class="ident">reverse_edge</span></code></dt>
<dd>
<section class="desc"><p>Initialize Graph with Data Structure passed by Argument or initialize everything with blank</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="python-graphs.modules.graph.graph.Graph.breadthStartSearch"><code class="name flex">
<span>def <span class="ident">breadthStartSearch</span></span>(<span>self, start_vertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs Breadth Search in Graph</p>
<h2 id="arguments">Arguments</h2>
<p>start_vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def breadthStartSearch(self, start_vertice):
    &#34;&#34;&#34;Performs Breadth Search in Graph
    
    Arguments:
        start_vertice {String|Integer}      -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    &#34;&#34;&#34;
    
    self.visited[start_vertice] = True
    queue = deque([])
    queue.append(start_vertice)

    while(queue):
        vertice = queue.popleft()
        for neighborhoodVertice in self.getVerticeNeighborhood(vertice):
            if(self.visited[neighborhoodVertice]):
                if(not self.explored[self.getSymbolicEdge(vertice, neighborhoodVertice)]):
                    self.exploreEdge(vertice, neighborhoodVertice)
            else:
                self.exploreEdge(vertice, neighborhoodVertice)
                self.discoverEdge(vertice, neighborhoodVertice)
                self.visited[neighborhoodVertice] = True
                queue.append(neighborhoodVertice)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.breadthStartToEndSearch"><code class="name flex">
<span>def <span class="ident">breadthStartToEndSearch</span></span>(<span>self, start_vertice, end_vertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs Breadth Search from a Start Vertice to an Destination Veretice
From Vertice A to B it will return a Graph with at least one path between those two points.</p>
<h2 id="arguments">Arguments</h2>
<p>start_vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
end_vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a>
&ndash; <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> <code>with</code> <code>at</code> <code>least</code> <code>one</code> <code>Path</code> <code>that</code> <code>exists</code> <code>from</code> <code>origin</code> <code>vertice</code> <code>to</code> <code>destination</code> <code>vertice</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def breadthStartToEndSearch(self, start_vertice, end_vertice):
    &#34;&#34;&#34;Performs Breadth Search from a Start Vertice to an Destination Veretice
       From Vertice A to B it will return a Graph with at least one path between those two points.
    
    Arguments:
        start_vertice {String|Integer}  -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        end_vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Returns:
        Graph   -- Graph with at least one Path that exists from origin vertice to destination vertice
    &#34;&#34;&#34;

    self.visited[start_vertice] = True
    queue = deque([])
    queue.append(start_vertice)
    
    graph = self.getGraphInstance(directed = self.directed)

    graph.createVertice(start_vertice)

    while(queue):
        vertice = queue.popleft()
        for neighborhoodVertice in self.getVerticeNeighborhood(vertice):
            
            if(self.visited[neighborhoodVertice]):
                if not self.explored[self.getSymbolicEdge(vertice, neighborhoodVertice)]:
                    self.exploreEdge(vertice, neighborhoodVertice)
                    graph.createEdge([vertice, neighborhoodVertice])
            else:
                self.exploreEdge(vertice, neighborhoodVertice)
                self.discoverEdge(vertice, neighborhoodVertice)
                self.visited[neighborhoodVertice] = True
                queue.append(neighborhoodVertice)
                graph.createVertice(neighborhoodVertice)
                graph.createEdge([vertice, neighborhoodVertice])
                
            if (neighborhoodVertice == end_vertice):
                return graph
        
    return None</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.clearEdges"><code class="name flex">
<span>def <span class="ident">clearEdges</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove all Edges from Graphs</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def clearEdges(self):
    &#34;&#34;&#34;Remove all Edges from Graphs
    &#34;&#34;&#34;
    for edge in list(self.getEdges().values()):
        self.removeEdge(edge)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.createCapacity"><code class="name flex">
<span>def <span class="ident">createCapacity</span></span>(<span>self, edge, capacity=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates Capacity for Edge</p>
<h2 id="arguments">Arguments</h2>
<p>edge {List}
&ndash; Edges as List. Example: [vertice1, vertice2]
Keyword Arguments:
capacity {int}
&ndash; Capacity Value for Edge (default: {0})</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code>
&ndash; <code>Capacity</code> <code>was</code> <code>created</code> or <code>not</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createCapacity(self, edge, capacity = 0):
    &#34;&#34;&#34;Creates Capacity for Edge
    
    Arguments:
        edge {List}         -- Edges as List. Example: [vertice1, vertice2]
    
    Keyword Arguments:
        capacity {int}      -- Capacity Value for Edge (default: {0})
    
    Returns:
        Boolean             -- Capacity was created or not
    &#34;&#34;&#34;
    if self.edgeExists(edge):
        self.capacity[self.getSymbolicEdge(edge[0], edge[1])] = capacity
        return True
        
    return False</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.createEdge"><code class="name flex">
<span>def <span class="ident">createEdge</span></span>(<span>self, edge)</span>
</code></dt>
<dd>
<section class="desc"><p>Create Edge in Graph</p>
<p><strong>Overriden Method by Child</strong></p>
<h2 id="arguments">Arguments</h2>
<p>edge {List}
&ndash; Edges as List. Example: [vertice1, vertice2]</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Edge already Exists in Graph</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createEdge(self, edge):
    &#34;&#34;&#34;Create Edge in Graph

    **Overriden Method by Child**
    
    Arguments:
        edge {List}             -- Edges as List. Example: [vertice1, vertice2]
    
    Raises:
        Exception: Edge already Exists in Graph
    &#34;&#34;&#34;
    if (self.edgeExists(edge) == False):
        self.graph[self.EDGES_KEY].append(edge)
        return
    
    raise Exception(&#39;Edge is already in Graph!&#39;)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.createFlow"><code class="name flex">
<span>def <span class="ident">createFlow</span></span>(<span>self, edge, flow=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates Flow for Edge</p>
<h2 id="arguments">Arguments</h2>
<p>edge {List}
&ndash; Edges as List. Example: [vertice1, vertice2]
Keyword Arguments:
flow {int}
&ndash; Flow Value for Edge (default: {0})</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code>
&ndash; <code>Flow</code> <code>was</code> <code>created</code> or <code>not</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createFlow(self, edge, flow = 0):
    &#34;&#34;&#34;Creates Flow for Edge
    
    Arguments:
        edge {List}         -- Edges as List. Example: [vertice1, vertice2]
    
    Keyword Arguments:
        flow {int}          -- Flow Value for Edge (default: {0})
    
    Returns:
        Boolean             -- Flow was created or not
    &#34;&#34;&#34;
    if self.edgeExists(edge):
        self.flow[self.getSymbolicEdge(edge[0], edge[1])] = flow
        return True
        
    return False</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.createVertice"><code class="name flex">
<span>def <span class="ident">createVertice</span></span>(<span>self, vertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Create Vertice in Graph</p>
<p><strong>Overriden Method by Child</strong></p>
<h2 id="arguments">Arguments</h2>
<p>vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Vertice Already Exists in Graph</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createVertice(self, vertice):
    &#34;&#34;&#34;Create Vertice in Graph

    **Overriden Method by Child**
    
    Arguments:
        vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Raises:
        Exception: Vertice Already Exists in Graph
    &#34;&#34;&#34;
    if (self.verticeExists(vertice) == False):
        self.graph[self.VERTICES_KEY].append(vertice)
        return
    
    raise Exception(&#39;Vertice is already in Graph!&#39;)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.createVertices"><code class="name flex">
<span>def <span class="ident">createVertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Create Many Vertices in Graph</p>
<h2 id="arguments">Arguments</h2>
<p>vertices {List}
&ndash; List of Vertices to be created.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createVertices(self, vertices):
    &#34;&#34;&#34;Create Many Vertices in Graph
    
    Arguments:
        vertices {List}         -- List of Vertices to be created.
    &#34;&#34;&#34;
    for vertice in vertices:
        self.createVertice(vertice)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.depthSearch"><code class="name flex">
<span>def <span class="ident">depthSearch</span></span>(<span>self, vertice, recursive=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Peforms Depth Search in Graph either on Recursive or Iterative Mode</p>
<h2 id="arguments">Arguments</h2>
<p>vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
Keyword Arguments:
recursive {bool}
&ndash; Execute using recursive method or iterative (default: {False})</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def depthSearch(self, vertice, recursive = False):
    &#34;&#34;&#34;Peforms Depth Search in Graph either on Recursive or Iterative Mode
    
    Arguments:
        vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Keyword Arguments:
        recursive {bool}            -- Execute using recursive method or iterative (default: {False})
    &#34;&#34;&#34;

    self.visited[vertice] = True
    
    if(recursive):
        for neighborhoodVertice in self.getVerticeNeighborhood(vertice):
            if(self.visited[neighborhoodVertice]):
                if not self.explored[self.getSymbolicEdge(vertice, neighborhoodVertice)]:
                    self.exploreEdge(vertice, neighborhoodVertice)
            else:
                self.exploreEdge(vertice, neighborhoodVertice)
                self.discoverEdge(vertice, neighborhoodVertice)
                self.depthSearch(neighborhoodVertice, True)
    else:
        stack = []
        stack.append([vertice, self.getVerticeNeighborhoodAfter(vertice)])

        while(stack):
            topStack = stack.pop()
            vertice = topStack[0]
            nextNeighborhoodVertice = topStack[1]

            if(nextNeighborhoodVertice &gt; 0):
                stack.append([vertice,self.getVerticeNeighborhoodAfter(vertice,nextNeighborhoodVertice)])
               
                if(self.visited[nextNeighborhoodVertice]):
                    if(not self.explored[self.getSymbolicEdge(vertice, nextNeighborhoodVertice)]):
                        self.exploreEdge(vertice, nextNeighborhoodVertice)
                else:
                    self.exploreEdge(vertice, nextNeighborhoodVertice)
                    self.discoverEdge(vertice, nextNeighborhoodVertice)
                    self.visited[nextNeighborhoodVertice] = True
                    stack.append([nextNeighborhoodVertice, self.getVerticeNeighborhoodAfter(nextNeighborhoodVertice)])</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.discoverEdge"><code class="name flex">
<span>def <span class="ident">discoverEdge</span></span>(<span>self, firstVertice, secondVertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Method to Discover Edge</p>
<h2 id="arguments">Arguments</h2>
<p>firstVertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
secondVertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def discoverEdge(self, firstVertice, secondVertice):
    &#34;&#34;&#34;Method to Discover Edge
    
    Arguments:
        firstVertice {String|Integer}       -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        secondVertice {String|Integer}      -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    &#34;&#34;&#34;
    self.discovered[self.getSymbolicEdge(firstVertice, secondVertice)] = True
    
    if (self.directed == False):
        self.discovered[self.getSymbolicEdge(secondVertice, firstVertice)] = True</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.distancesToVertice"><code class="name flex">
<span>def <span class="ident">distancesToVertice</span></span>(<span>self, vertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Get All Vertice Distances to One Specified Vertice
Example: distancesToVertice(1) -&gt; Returns a List of All Vertices and their distances to Vertice 1</p>
<h2 id="arguments">Arguments</h2>
<p>vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="returns">Returns</h2>
<p>[List]
&ndash; List of Vertices containing their Distances</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def distancesToVertice(self, vertice):
    &#34;&#34;&#34;Get All Vertice Distances to One Specified Vertice
       Example: distancesToVertice(1) -&gt; Returns a List of All Vertices and their distances to Vertice 1
    
    Arguments:
        vertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Returns:
        [List]      -- List of Vertices containing their Distances
    &#34;&#34;&#34;
    
    distances = {}
    
    for _vertice in self.getVertices():
        distances[_vertice] = None
    
    queue = deque([])
    
    self.visited[vertice] = True
    
    queue.append([vertice, 1])
    
    while(len(queue) &gt; 0):
        popedEdge = queue.popleft()
        
        for neighborhoodVertice in self.getVerticeNeighborhood(popedEdge[0]):
            if self.visited[neighborhoodVertice]:
                if not self.explored[self.getSymbolicEdge(popedEdge[0], neighborhoodVertice)]:
                    self.exploreEdge(popedEdge[0], neighborhoodVertice)
            else:
                self.exploreEdge(popedEdge[0], neighborhoodVertice)
                self.discoverEdge(popedEdge[0], neighborhoodVertice)
                
                self.visited[neighborhoodVertice] = True
                
                distances[neighborhoodVertice] = popedEdge[1]

                queue.append([neighborhoodVertice, popedEdge[1] + 1])
                
    return distances</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.edgeExists"><code class="name flex">
<span>def <span class="ident">edgeExists</span></span>(<span>self, edge)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if Edges Exists</p>
<p><strong>Overriden Method by Child</strong></p>
<h2 id="arguments">Arguments</h2>
<p>edge {List}
&ndash; Edges as List. Example: [vertice1, vertice2]</p>
<h2 id="returns">Returns</h2>
<p>Boolean
&ndash; Either Edge Exists or Not.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def edgeExists(self, edge):
    &#34;&#34;&#34;Check if Edges Exists

    **Overriden Method by Child**
    
    Arguments:
        edge {List}       -- Edges as List. Example: [vertice1, vertice2]
    
    Returns:
        Boolean           -- Either Edge Exists or Not.
    &#34;&#34;&#34;
    
    v1 = edge[0]
    v2 = edge[1]
    
    return [v1, v2] in self.graph[self.EDGES_KEY] or [v2, v1] in self.graph[self.EDGES_KEY]</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.edgesCount"><code class="name flex">
<span>def <span class="ident">edgesCount</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Count Number of Edges</p>
<h2 id="returns">Returns</h2>
<p>[Integer]
&ndash; Number of Edges</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def edgesCount(self):
    &#34;&#34;&#34;Count Number of Edges
    
    Returns:
        [Integer]   -- Number of Edges
    &#34;&#34;&#34;
    return len(self.getEdges())</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.exploreEdge"><code class="name flex">
<span>def <span class="ident">exploreEdge</span></span>(<span>self, firstVertice, secondVertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Method to Explore Edge</p>
<h2 id="arguments">Arguments</h2>
<p>firstVertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
secondVertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exploreEdge(self, firstVertice, secondVertice):
    &#34;&#34;&#34;Method to Explore Edge
    
    Arguments:
        firstVertice {String|Integer}       -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        secondVertice {String|Integer}      -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    &#34;&#34;&#34;
    self.explored[self.getSymbolicEdge(firstVertice, secondVertice)] = True
    
    if (self.directed == False):
        self.explored[self.getSymbolicEdge(secondVertice, firstVertice)] = True</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.fullSearch"><code class="name flex">
<span>def <span class="ident">fullSearch</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Full Search Method for Graph, performs search in every Vertice in Graph.
Visiting, Exploring and Discovering Every Vertice and Edge in Graph.
Complexity: Î¸(n+m)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fullSearch(self):
    &#34;&#34;&#34;Full Search Method for Graph, performs search in every Vertice in Graph.
       Visiting, Exploring and Discovering Every Vertice and Edge in Graph.
       Complexity: Î¸(n+m)
    &#34;&#34;&#34;
    for vertice in self.getVertices():
        if(self.visited[vertice] == False):
            self.search(vertice)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getAllGraphPaths"><code class="name flex">
<span>def <span class="ident">getAllGraphPaths</span></span>(<span>self, origin_vertice, destination_vertice, visited, paths, graphs_paths)</span>
</code></dt>
<dd>
<section class="desc"><p>Get All Paths from one Origin Vertice to a Destination Vertice
From Vertice A to B returns a List of Graphs containing all Paths between those two Vertices</p>
<h2 id="arguments">Arguments</h2>
<p>origin_vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
destination_vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
visited {List}
&ndash; Visited List of Vertices ( Passed by Reference )
paths {List}
&ndash; List of Paths ( Passed by Reference )
graphs_paths {List}
&ndash; List of Graph's Paths ( Passed by Reference )</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getAllGraphPaths(self, origin_vertice, destination_vertice, visited, paths, graphs_paths):
    &#34;&#34;&#34;Get All Paths from one Origin Vertice to a Destination Vertice
       From Vertice A to B returns a List of Graphs containing all Paths between those two Vertices
    
    Arguments:
        origin_vertice {String|Integer}                 -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        destination_vertice {String|Integer}            -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        visited {List}                                  -- Visited List of Vertices ( Passed by Reference )
        paths {List}                                    -- List of Paths ( Passed by Reference )
        graphs_paths {List}                             -- List of Graph&#39;s Paths ( Passed by Reference )
    &#34;&#34;&#34;

    # Mark the current node as visited and store in path 
    visited[origin_vertice] = True
    paths.append(origin_vertice) 

    # If current vertex is same as destination, then print 
    # current path[] 
    if (origin_vertice == destination_vertice):
        
        graph = self.getGraphInstance(directed = self.directed)
        
        index = 0
        
        for i in range(len(paths)):
            
            vertice = paths[i]
            
            if not graph.verticeExists(vertice):
                graph.createVertice(vertice)
            
            if (i &lt; len(paths) - 1):
                
                next_vertice = paths[i + 1]
                
                if not graph.verticeExists(next_vertice):
                    graph.createVertice(next_vertice)
                
                graph.createEdge([vertice, next_vertice])
                
        graphs_paths.append(graph)
    else: 
        # If current vertex is not destination 
        #Recur for all the vertices adjacent to this vertex 
        for neighborhoodVertice in self.getVerticeNeighborhood(origin_vertice): 
            if (visited[neighborhoodVertice] == False): 
                self.getAllGraphPaths(neighborhoodVertice, destination_vertice, visited, paths, graphs_paths) 
                  
    # Remove current vertex from path[] and mark it as unvisited 
    paths.pop()
    
    visited[origin_vertice] = False</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getEdges"><code class="name flex">
<span>def <span class="ident">getEdges</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Graph's Edges List</p>
<p><strong>Overriden Method by Child</strong></p>
<h2 id="returns">Returns</h2>
<p>[List]
&ndash; Edges List</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getEdges(self):
    &#34;&#34;&#34;Get Graph&#39;s Edges List

    **Overriden Method by Child**
    
    Returns:
        [List]      -- Edges List
    &#34;&#34;&#34;
    return self.graph[self.EDGES_KEY]</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getForestGeneratorGraph"><code class="name flex">
<span>def <span class="ident">getForestGeneratorGraph</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Forest Generator Graph
Complexity: O(n+m) </p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a>
&ndash; <code>Returns</code> <code>Forest</code> <code>Generator</code> <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> <code>for</code> <code>the</code> <code>current</code> <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> <code>itself</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getForestGeneratorGraph(self):
    &#34;&#34;&#34;Get Forest Generator Graph
       Complexity: O(n+m) 
    
    Returns:
        Graph       -- Returns Forest Generator Graph for the current Graph itself
    &#34;&#34;&#34;
    
    newGraph = self.getGraphInstance(directed = self.directed)
    
    newGraph.createVertices(self.getVertices())

    self.fullSearch()
    
    for edge in list(self.getEdges().values()):
        symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
        if self.discovered[symbolic_edge]:
            newGraph.createEdge(edge)
            
    return newGraph</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getGraph"><code class="name flex">
<span>def <span class="ident">getGraph</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return Original Graph Data Structure ( This method is not public as it is overriden by child classes )</p>
<p><strong>Overriden Method by Child</strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dictionary</code> &ndash; <code>Return</code> <code>initial</code> <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> <code>Data</code> <code>Structure</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getGraph(self):
    &#34;&#34;&#34;Return Original Graph Data Structure ( This method is not public as it is overriden by child classes )

    **Overriden Method by Child**
    
    Returns:
        Dictionary -- Return initial Graph Data Structure
    &#34;&#34;&#34;
    return self.graph</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getGraphInstance"><code class="name flex">
<span>def <span class="ident">getGraphInstance</span></span>(<span>self, deep_copy=False, directed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Self Graph Instance as a Copy or New One</p>
<p><strong>Method Overriden by Child Class</strong></p>
<p>Keyword Arguments:
deep_copy {bool}
&ndash; Generate a new copy of itself or a new one (default: {False})
directed {bool}
&ndash; If New Graph should be Directed or Not (default: {False})</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Method not Implemented</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getGraphInstance(self, deep_copy = False, directed = False):
    &#34;&#34;&#34;Get Self Graph Instance as a Copy or New One

       **Method Overriden by Child Class**
    
    Keyword Arguments:
        deep_copy {bool}    -- Generate a new copy of itself or a new one (default: {False})
        directed {bool}     -- If New Graph should be Directed or Not (default: {False})
    
    Raises:
        Exception: Method not Implemented
    &#34;&#34;&#34;
    raise Exception(&#39;graphInstance() Not Implemented! You need to Implement in your class simply returning its self new instance&#39;)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getGraphPaths"><code class="name flex">
<span>def <span class="ident">getGraphPaths</span></span>(<span>self, origin_vertice, destination_vertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Get All Paths from one Origin Vertice to a Destination Vertice
From Vertice A to B returns a List of Graphs containing all Paths between those two Vertices</p>
<p>Related To: getAllGraphPaths()</p>
<h2 id="arguments">Arguments</h2>
<p>origin_vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
destination_vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="returns">Returns</h2>
<p>[List]
&ndash; List of Graph's Paths</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getGraphPaths(self, origin_vertice, destination_vertice):
    &#34;&#34;&#34;Get All Paths from one Origin Vertice to a Destination Vertice
       From Vertice A to B returns a List of Graphs containing all Paths between those two Vertices
       
       Related To: getAllGraphPaths()
    
    Arguments:
        origin_vertice {String|Integer}             -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        destination_vertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Returns:
        [List]      -- List of Graph&#39;s Paths
    &#34;&#34;&#34;

    paths = []
    
    graphs_paths = []
    
    visited = {}

    for vertice in self.getVertices():
        visited[vertice] = False
    
    self.getAllGraphPaths(origin_vertice, destination_vertice, visited, paths, graphs_paths)
    
    return graphs_paths</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getMaxFlow"><code class="name flex">
<span>def <span class="ident">getMaxFlow</span></span>(<span>self, source, sink)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Max Flow from a Directed Graph
Related To: getResidualGraph()</p>
<h2 id="arguments">Arguments</h2>
<p>source {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
sink {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Graph is not Directed!</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Integer</code>
&ndash; <code>Value</code> of <code>Max</code> <code>Flow</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getMaxFlow(self, source, sink):
    &#34;&#34;&#34;Get Max Flow from a Directed Graph
       Related To: getResidualGraph()
    
    Arguments:
        source {String|Integer}         -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        sink {String|Integer}           -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Raises:
        Exception: Graph is not Directed!
    
    Returns:
        Integer         -- Value of Max Flow
    &#34;&#34;&#34;
    
    if (self.directed == False):
        raise Exception(&#39;Current Graph is not Directed! Transform it to Directed Graph to use MaxFlow!&#39;)
    
    #flow = {}
    
    max_flow_digraph = 0
    
    for edge in list(self.getEdges().values()):
        self.flow[self.getSymbolicEdge(edge[0], edge[1])] = 0
        
    residual_digraph = self.getResidualGraph(source, sink)
    
    try:
        residual_possible_paths = residual_digraph.breadthStartToEndSearch(source, sink).getGraphPaths(source, sink)
    except AttributeError:  
        return 0
    
    # residual_possible_paths = residual_digraph.getGraphPaths(source, sink)
    
    digraph_path = random.choice(residual_possible_paths)
    
    residual_capacity = 0
    
    while (digraph_path != None):
        
        residual_capacity = min(list(self.reverse_edge.values()))
        
        max_flow_digraph += residual_capacity
        
        for edge in list(digraph_path.getEdges().values()):
            
            symbolic_edge = digraph_path.getSymbolicEdge(edge[0], edge[1])
            
            inverse_symbolic_edge = digraph_path.getSymbolicEdge(edge[1], edge[0])
            
            if (self.sink[symbolic_edge]):
                self.flow[symbolic_edge] += residual_capacity
            else:
                self.flow[inverse_symbolic_edge] -= residual_capacity
                
        residual_digraph = self.getResidualGraph(source, sink)
        
        # possible_digraph_paths = residual_digraph.getGraphPaths(source, sink)
        possible_paths = residual_digraph.breadthStartToEndSearch(source, sink)
        
        if possible_paths is not None:
            digraph_path = random.choice(possible_paths.getGraphPaths(source, sink))
        else:
            digraph_path = None
        
        # if possible_digraph_paths:
        #    digraph_path = random.choice(possible_digraph_paths)
        #else:
        #    digraph_path = None
        
    return max_flow_digraph</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getName"><code class="name flex">
<span>def <span class="ident">getName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Graph's Name</p>
<h2 id="returns">Returns</h2>
<p>[String]
&ndash; Graph's Name</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getName(self):
    &#34;&#34;&#34;Get Graph&#39;s Name
    
    Returns:
        [String]        -- Graph&#39;s Name
    &#34;&#34;&#34;
    return self.graph[self.GRAPH_NAME_KEY]</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getResidualGraph"><code class="name flex">
<span>def <span class="ident">getResidualGraph</span></span>(<span>self, source, sink)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Residual Graph for MaxFlow usage
Related To: MaxFlow()</p>
<h2 id="arguments">Arguments</h2>
<p>source {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
sink {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Graph is not Directed!</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a>
&ndash; <code>Residual</code> <code>Generated</code> <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getResidualGraph(self, source, sink):
    &#34;&#34;&#34;Get Residual Graph for MaxFlow usage
       Related To: MaxFlow()
    
    Arguments:
        source {String|Integer}         -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        sink {String|Integer}           -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Raises:
        Exception: Graph is not Directed!
    
    Returns:
        Graph       -- Residual Generated Graph
    &#34;&#34;&#34;
    
    if (self.directed == False):
        raise Exception(&#39;Current Graph is not Directed! Transform it to Directed Graph to use ResidualGraph!&#39;)
    
    residual_digraph = self.getGraphInstance(deep_copy = True)
    
    residual_digraph.clearEdges()
    
    for edge in list(self.getEdges().values()):
        
        symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
        
        reverse_symbolic_edge = self.getSymbolicEdge(edge[1], edge[0])
        
        if (self.capacity[symbolic_edge] - self.flow[symbolic_edge]) &gt; 0:
            residual_digraph.createEdge(edge)
            self.reverse_edge[symbolic_edge] = self.capacity[symbolic_edge] - self.flow[symbolic_edge]
            self.sink[symbolic_edge] = True
        elif (self.flow[symbolic_edge] &gt; 0):
            residual_digraph.createEdge([edge[1], edge[0]])
            self.reverse_edge[reverse_symbolic_edge] = self.flow[symbolic_edge]
            self.sink[reverse_symbolic_edge] = False
            
    return residual_digraph</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getSymbolicEdge"><code class="name flex">
<span>def <span class="ident">getSymbolicEdge</span></span>(<span>self, firstVertice, secondVertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Symbolic Edge as String. Example: firstVertice: 0 and secondVertice: 1 turns to '01'
So it can be used as Dictionary Key</p>
<h2 id="arguments">Arguments</h2>
<p>firstVertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
secondVertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="returns">Returns</h2>
<p>[String]
&ndash; Symbolic Key of Vertices as String. Example: firstVertice: 0 and secondVertice: 1 turns to '01'</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getSymbolicEdge(self, firstVertice, secondVertice):
    &#34;&#34;&#34;Get Symbolic Edge as String. Example: firstVertice: 0 and secondVertice: 1 turns to &#39;01&#39;
       So it can be used as Dictionary Key
    
    Arguments:
        firstVertice {String|Integer}         -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
        secondVertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Returns:
        [String]                              -- Symbolic Key of Vertices as String. Example: firstVertice: 0 and secondVertice: 1 turns to &#39;01&#39;
    &#34;&#34;&#34;
    return str(firstVertice) + str(secondVertice)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getVerticeNeighborhood"><code class="name flex">
<span>def <span class="ident">getVerticeNeighborhood</span></span>(<span>self, vertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Get All Vertices in a Vertice(V1) Neighborhood
Example: v1 has [v2,v3,v4] as adjacency vertices, this methods returns those vertices</p>
<h2 id="arguments">Arguments</h2>
<p>vertice {String|Vertice}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Method Not Implemented in Child Class!</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getVerticeNeighborhood(self, vertice):
    &#34;&#34;&#34;Get All Vertices in a Vertice(V1) Neighborhood
       Example: v1 has [v2,v3,v4] as adjacency vertices, this methods returns those vertices
    
    Arguments:
        vertice {String|Vertice}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Raises:
        Exception: Method Not Implemented in Child Class!
    &#34;&#34;&#34;
    raise Exception(&#39;getVerticeNeighborhood(vertice) Not Implemented! You need to Implement this method in your class!&#39;)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getVerticeNeighborhoodAfter"><code class="name flex">
<span>def <span class="ident">getVerticeNeighborhoodAfter</span></span>(<span>self, vertice, neighborhoodVertice=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Vertices Neighborhood of a Vertice after some Vertice Neighborhood.
Example: Vertices neighborhood for v1 is [v2,v3,v4]
neighborhoodVertice value is v3 then result will be v4. </p>
<h2 id="arguments">Arguments</h2>
<p>vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.
Keyword Arguments:
neighborhoodVertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive. (default: {None})</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code>
&ndash; <code>List</code> of <code>Vertices</code> <code>Neighborhood</code> <code>after</code> <code>a</code> <code>given</code> <code>vertice</code> <code>inside</code> <code>the</code> <code>neighborhood</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getVerticeNeighborhoodAfter(self, vertice, neighborhoodVertice = None):
    &#34;&#34;&#34;Get Vertices Neighborhood of a Vertice after some Vertice Neighborhood.
       Example: Vertices neighborhood for v1 is [v2,v3,v4]
                neighborhoodVertice value is v3 then result will be v4. 
    
    Arguments:
        vertice {String|Integer}                -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Keyword Arguments:
        neighborhoodVertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive. (default: {None})
    
    Returns:
        List        -- List of Vertices Neighborhood after a given vertice inside the neighborhood
    &#34;&#34;&#34;
    
    verticeNeighborhoodList = self.getVerticeNeighborhood(vertice)
    
    if not verticeNeighborhoodList:
        return 0
    else:
        if(neighborhoodVertice is None):
            return verticeNeighborhoodList[0]
    
    indexAfter = verticeNeighborhoodList.index(neighborhoodVertice)+1
    try:
        if(verticeNeighborhoodList[indexAfter]):
            return verticeNeighborhoodList[indexAfter]
    except IndexError:  
        return 0</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.getVertices"><code class="name flex">
<span>def <span class="ident">getVertices</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Graph's Vertices List</p>
<p><strong>Overriden Method by Child</strong></p>
<h2 id="returns">Returns</h2>
<p>[List]
&ndash; Vertices List</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getVertices(self):
    &#34;&#34;&#34; Get Graph&#39;s Vertices List

    **Overriden Method by Child**
    
    Returns:
        [List]     -- Vertices List
    &#34;&#34;&#34;
    return self.graph[self.VERTICES_KEY]</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.hasCicle"><code class="name flex">
<span>def <span class="ident">hasCicle</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if Graph has Cicle or Not
Complexity: O(n+m)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code>
&ndash; <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> <code>has</code> <code>Cicle</code> or <code>Not</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hasCicle(self):
    &#34;&#34;&#34;Check if Graph has Cicle or Not
       Complexity: O(n+m)
    Returns:
        Boolean         -- Graph has Cicle or Not
    &#34;&#34;&#34;
    self.fullSearch()
    
    for edge in self.getEdges().keys():
        if not self.discovered[edge]:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.hasForest"><code class="name flex">
<span>def <span class="ident">hasForest</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if Graph has Forest or Not
Complexity: O(n+m)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code>
&ndash; <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> <code>has</code> <code>a</code> <code>Forest</code> or <code>Not</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hasForest(self):
    &#34;&#34;&#34;Check if Graph has Forest or Not
       Complexity: O(n+m)
    
    Returns:
        Boolean         -- Graph has a Forest or Not
    &#34;&#34;&#34;
    return not self.hasCicle() </code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.initializeEdge"><code class="name flex">
<span>def <span class="ident">initializeEdge</span></span>(<span>self, edge)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize Edge with default Setup such as explored, discovered to default values as they are global
Similar To: initializeVertice(self, vertice)</p>
<h2 id="arguments">Arguments</h2>
<p>edge {List}
&ndash; Edges as List. Example: [vertice1, vertice2]</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def initializeEdge(self, edge):
    &#34;&#34;&#34;Initialize Edge with default Setup such as explored, discovered to default values as they are global
       Similar To: initializeVertice(self, vertice)
    
    Arguments:
        edge {List}                           -- Edges as List. Example: [vertice1, vertice2]
    &#34;&#34;&#34;
    symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
    
    self.explored[symbolic_edge] = False
    
    self.discovered[symbolic_edge] = False
    
    self.createFlow(edge, 0)
    
    self.createCapacity(edge, 0)
    
    self.sink[symbolic_edge] = False

    if (self.directed == False):
        inversed_symbolic_edge = self.getSymbolicEdge(edge[1], edge[0])
        self.explored[inversed_symbolic_edge] = False
        self.discovered[inversed_symbolic_edge] = False</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.initializeVertice"><code class="name flex">
<span>def <span class="ident">initializeVertice</span></span>(<span>self, vertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize Vertice with default setup such as Visited to default values as they are global
Similar To: initializeEdge(self, edge)</p>
<h2 id="arguments">Arguments</h2>
<p>vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def initializeVertice(self, vertice):
    &#34;&#34;&#34;Initialize Vertice with default setup such as Visited to default values as they are global
       Similar To: initializeEdge(self, edge)
    
    Arguments:
        vertice {String|Integer}            -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    &#34;&#34;&#34;
    self.visited[vertice] = False</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.isConnected"><code class="name flex">
<span>def <span class="ident">isConnected</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if Graph is Connected or Not
Complexity: O(n+m)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code>
&ndash; <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> <code>is</code> <code>Connected</code> or <code>Not</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isConnected(self):
    &#34;&#34;&#34;Check if Graph is Connected or Not
       Complexity: O(n+m)
    
    Returns:
        Boolean         -- Graph is Connected or Not
    &#34;&#34;&#34;
    self.search()
    for vertice in self.getVertices():
        if(self.visited[vertice] == False):
            return False
    return True</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.isTree"><code class="name flex">
<span>def <span class="ident">isTree</span></span>(<span>self, alternative=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if Graph is a Tree or Not
Complexity: O(n+m) </p>
<p>Keyword Arguments:
alternative {bool}
&ndash; Use Alternative Method to Verify if Is Tree. First uses Search and Second Uses isConnected() and not HasCicle()
(default: {False})</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code>
&ndash; <a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph"><code>Graph</code></a> <code>is</code> <code>a</code> <code>Tree</code> or <code>Not</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isTree(self, alternative = False):
    &#34;&#34;&#34;Check if Graph is a Tree or Not
       Complexity: O(n+m) 

    Keyword Arguments:
        alternative {bool}  -- Use Alternative Method to Verify if Is Tree. First uses Search and Second Uses isConnected() and not HasCicle()  (default: {False})
    
    Returns:
        Boolean             -- Graph is a Tree or Not
    &#34;&#34;&#34;
    
    if not alternative:
        self.search()
        
        for vertice in self.getVertices():
            if(self.visited[vertice] == False):
                return False
        
        for edge in list(self.getEdges().values()):
            symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
            if(self.discovered[symbolic_edge] == False):
                return False
    else:
        return self.isConnected() and not self.hasCicle()

    return True</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.removeEdge"><code class="name flex">
<span>def <span class="ident">removeEdge</span></span>(<span>self, edge)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove Edge from Graph</p>
<p><strong>Overriden Method by Child</strong></p>
<h2 id="arguments">Arguments</h2>
<p>edge {List}
&ndash; Edges as List. Example: [vertice1, vertice2]</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Edge doesn't Exists in Graph</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def removeEdge(self, edge):
    &#34;&#34;&#34;Remove Edge from Graph

    **Overriden Method by Child**
    
    Arguments:
        edge {List}         -- Edges as List. Example: [vertice1, vertice2]
    
    Raises:
        Exception: Edge doesn&#39;t Exists in Graph
    &#34;&#34;&#34;
    if (self.edgeExists(edge)):
        del self.graph[self.EDGES_KEY][edge]
        return
    
    raise Exception(&#39;Edge not Found in Graph!&#39;)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.removeVertice"><code class="name flex">
<span>def <span class="ident">removeVertice</span></span>(<span>self, vertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove Vertice from Graph</p>
<h2 id="arguments">Arguments</h2>
<p>vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Method not Implemented!</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def removeVertice(self, vertice):
    &#34;&#34;&#34;Remove Vertice from Graph
    
    Arguments:
        vertice {String|Integer}    -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Raises:
        Exception: Method not Implemented!
    &#34;&#34;&#34;
    
    raise Exception(&#39;removeVertice(self,vertice) is not Implemented!&#39;)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.resetState"><code class="name flex">
<span>def <span class="ident">resetState</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Reset State for the Graph. Basically resets global variables to default value</p>
<p>Values reseted: visited, sink, discovered, expored, reverse_edge, flow, capacity</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def resetState(self):
    &#34;&#34;&#34;Reset State for the Graph. Basically resets global variables to default value

       Values reseted: visited, sink, discovered, expored, reverse_edge, flow, capacity
    &#34;&#34;&#34;
    for vertice in self.visited:
        self.visited[vertice] = False
        
    for sink in self.sink:
        self.sink[sink] = False
        
    for discovered in self.discovered:
        self.discovered[discovered] = False
        
    for explored in self.explored:
        self.explored[explored] = False
        
    for reverse in self.reverse_edge:
        self.reverse_edge[reverse] = 0
        
    for flow in self.flow:
        self.flow[flow] = 0
        
    for capacity in self.capacity:
        self.capacity[capacity] = 0</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, vertice=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Search Method for Graph, performs Search initializing from a random or choosen vertice.
Visiting, Exploring and Discovering Every Vertice and Edge in Graph.
Complexity: O(n+m)</p>
<p>Keyword Arguments:
vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive. (default: {None})</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search(self, vertice = None):
    &#34;&#34;&#34;Search Method for Graph, performs Search initializing from a random or choosen vertice.
       Visiting, Exploring and Discovering Every Vertice and Edge in Graph.
       Complexity: O(n+m)
    
    Keyword Arguments:
        vertice {String|Integer}        -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive. (default: {None})
    &#34;&#34;&#34;
    if vertice is None:
        # Choosing Randomly Doesn&#39;t Work so instead choose the first one
        # root_vertice = random.choices(list(self.list_graph.keys()), k=1)
        root_vertice = list(self.getVertices())
        self.visited[root_vertice[0]] = True
    else:
        self.visited[vertice] = True
        
    for edge in list(self.getEdges().values()):
        symbolic_edge = self.getSymbolicEdge(edge[0], edge[1])
        if (self.visited[edge[0]] and not self.explored[symbolic_edge]):
            self.explored[symbolic_edge] = True
            
            if not self.visited[edge[1]]:
                self.visited[edge[1]], self.discovered[symbolic_edge] = True, True</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.setName"><code class="name flex">
<span>def <span class="ident">setName</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Define Graph's Name</p>
<h2 id="arguments">Arguments</h2>
<p>name {String}
&ndash; Graph's Name</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setName(self, name):
    &#34;&#34;&#34;Define Graph&#39;s Name
    
    Arguments:
        name {String}    -- Graph&#39;s Name
    &#34;&#34;&#34;
    self.graph[self.GRAPH_NAME_KEY] = name</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Print Current Graph into Console.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show(self):
    &#34;&#34;&#34; Print Current Graph into Console.
    &#34;&#34;&#34;
    print(self.graph)</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.verticeExists"><code class="name flex">
<span>def <span class="ident">verticeExists</span></span>(<span>self, vertice)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if Vertice Exists</p>
<p><strong>Overriden Method by Child</strong></p>
<h2 id="arguments">Arguments</h2>
<p>vertice {String|Integer}
&ndash; Vertice Key Name. Example: Vertice 'a' or Vertice 2. Name doesn't matter as long it is a primitive.</p>
<h2 id="returns">Returns</h2>
<p>[Boolean]
&ndash; Condition to check if vertice exists</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def verticeExists(self, vertice):
    &#34;&#34;&#34;Check if Vertice Exists

    **Overriden Method by Child**
    
    Arguments:
        vertice {String|Integer}  -- Vertice Key Name. Example: Vertice &#39;a&#39; or Vertice 2. Name doesn&#39;t matter as long it is a primitive.
    
    Returns:
        [Boolean]         -- Condition to check if vertice exists
    &#34;&#34;&#34;
    return vertice in self.graph[self.VERTICES_KEY]</code></pre>
</details>
</dd>
<dt id="python-graphs.modules.graph.graph.Graph.verticesCount"><code class="name flex">
<span>def <span class="ident">verticesCount</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Count Number of Vertices</p>
<h2 id="returns">Returns</h2>
<p>[Integer]
&ndash; Number of Vertices</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def verticesCount(self):
    &#34;&#34;&#34;Count Number of Vertices
    
    Returns:
        [Integer]   -- Number of Vertices
    &#34;&#34;&#34;
    return len(self.getVertices())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="python-graphs.modules.graph" href="index.html">python-graphs.modules.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="python-graphs.modules.graph.graph.Graph" href="#python-graphs.modules.graph.graph.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="python-graphs.modules.graph.graph.Graph.EDGES_KEY" href="#python-graphs.modules.graph.graph.Graph.EDGES_KEY">EDGES_KEY</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.GRAPH_NAME_KEY" href="#python-graphs.modules.graph.graph.Graph.GRAPH_NAME_KEY">GRAPH_NAME_KEY</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.VERTICES_KEY" href="#python-graphs.modules.graph.graph.Graph.VERTICES_KEY">VERTICES_KEY</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.breadthStartSearch" href="#python-graphs.modules.graph.graph.Graph.breadthStartSearch">breadthStartSearch</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.breadthStartToEndSearch" href="#python-graphs.modules.graph.graph.Graph.breadthStartToEndSearch">breadthStartToEndSearch</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.clearEdges" href="#python-graphs.modules.graph.graph.Graph.clearEdges">clearEdges</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.createCapacity" href="#python-graphs.modules.graph.graph.Graph.createCapacity">createCapacity</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.createEdge" href="#python-graphs.modules.graph.graph.Graph.createEdge">createEdge</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.createFlow" href="#python-graphs.modules.graph.graph.Graph.createFlow">createFlow</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.createVertice" href="#python-graphs.modules.graph.graph.Graph.createVertice">createVertice</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.createVertices" href="#python-graphs.modules.graph.graph.Graph.createVertices">createVertices</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.depthSearch" href="#python-graphs.modules.graph.graph.Graph.depthSearch">depthSearch</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.discoverEdge" href="#python-graphs.modules.graph.graph.Graph.discoverEdge">discoverEdge</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.distancesToVertice" href="#python-graphs.modules.graph.graph.Graph.distancesToVertice">distancesToVertice</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.edgeExists" href="#python-graphs.modules.graph.graph.Graph.edgeExists">edgeExists</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.edgesCount" href="#python-graphs.modules.graph.graph.Graph.edgesCount">edgesCount</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.exploreEdge" href="#python-graphs.modules.graph.graph.Graph.exploreEdge">exploreEdge</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.fullSearch" href="#python-graphs.modules.graph.graph.Graph.fullSearch">fullSearch</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getAllGraphPaths" href="#python-graphs.modules.graph.graph.Graph.getAllGraphPaths">getAllGraphPaths</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getEdges" href="#python-graphs.modules.graph.graph.Graph.getEdges">getEdges</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getForestGeneratorGraph" href="#python-graphs.modules.graph.graph.Graph.getForestGeneratorGraph">getForestGeneratorGraph</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getGraph" href="#python-graphs.modules.graph.graph.Graph.getGraph">getGraph</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getGraphInstance" href="#python-graphs.modules.graph.graph.Graph.getGraphInstance">getGraphInstance</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getGraphPaths" href="#python-graphs.modules.graph.graph.Graph.getGraphPaths">getGraphPaths</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getMaxFlow" href="#python-graphs.modules.graph.graph.Graph.getMaxFlow">getMaxFlow</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getName" href="#python-graphs.modules.graph.graph.Graph.getName">getName</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getResidualGraph" href="#python-graphs.modules.graph.graph.Graph.getResidualGraph">getResidualGraph</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getSymbolicEdge" href="#python-graphs.modules.graph.graph.Graph.getSymbolicEdge">getSymbolicEdge</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getVerticeNeighborhood" href="#python-graphs.modules.graph.graph.Graph.getVerticeNeighborhood">getVerticeNeighborhood</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getVerticeNeighborhoodAfter" href="#python-graphs.modules.graph.graph.Graph.getVerticeNeighborhoodAfter">getVerticeNeighborhoodAfter</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.getVertices" href="#python-graphs.modules.graph.graph.Graph.getVertices">getVertices</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.hasCicle" href="#python-graphs.modules.graph.graph.Graph.hasCicle">hasCicle</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.hasForest" href="#python-graphs.modules.graph.graph.Graph.hasForest">hasForest</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.initializeEdge" href="#python-graphs.modules.graph.graph.Graph.initializeEdge">initializeEdge</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.initializeVertice" href="#python-graphs.modules.graph.graph.Graph.initializeVertice">initializeVertice</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.isConnected" href="#python-graphs.modules.graph.graph.Graph.isConnected">isConnected</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.isTree" href="#python-graphs.modules.graph.graph.Graph.isTree">isTree</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.removeEdge" href="#python-graphs.modules.graph.graph.Graph.removeEdge">removeEdge</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.removeVertice" href="#python-graphs.modules.graph.graph.Graph.removeVertice">removeVertice</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.resetState" href="#python-graphs.modules.graph.graph.Graph.resetState">resetState</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.reverse_edge" href="#python-graphs.modules.graph.graph.Graph.reverse_edge">reverse_edge</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.search" href="#python-graphs.modules.graph.graph.Graph.search">search</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.setName" href="#python-graphs.modules.graph.graph.Graph.setName">setName</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.show" href="#python-graphs.modules.graph.graph.Graph.show">show</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.verticeExists" href="#python-graphs.modules.graph.graph.Graph.verticeExists">verticeExists</a></code></li>
<li><code><a title="python-graphs.modules.graph.graph.Graph.verticesCount" href="#python-graphs.modules.graph.graph.Graph.verticesCount">verticesCount</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>